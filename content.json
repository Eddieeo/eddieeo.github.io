{"meta":{"title":"Hexo","subtitle":null,"description":"This a Blog about IT technosphere.","author":"Eddieeo","url":"https://linuxops.fun","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-10-30T16:46:16.312Z","updated":"2019-10-30T16:46:16.312Z","comments":false,"path":"/404.html","permalink":"https://linuxops.fun//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-10-30T16:46:16.340Z","updated":"2019-10-30T16:46:16.340Z","comments":false,"path":"about/index.html","permalink":"https://linuxops.fun/about/index.html","excerpt":"","text":"{name: ‘蔡喜得’age: 25,gender: ‘男’,profession: ‘Internet Operations &amp; Development’,experience: ‘5年’,address: ‘广东省深圳市’,github: ‘https://github.com/Eddieeo’,blog: ‘https://eddieeo.github.io’,email: ‘eddieeo@163.com’,description: ‘致力于互联网 Linux 运维与开发工作’,skills: [[‘Python’, ‘Go’, ‘Shell’],[‘Nginx’, ‘Jumpserver’, ‘Gitlab’, ‘Jenkins’, ‘Docker’],[‘Ansible’,‘Slatstack’],[‘Git’],],devTools: [[‘Sublime Text’, ‘Notepad++’],[‘Chrome DevTools’],[‘GitDesk’],[‘Navicat’, ‘Edraw MAX’, ‘Ps’, ‘Pycharm’, ‘Goland’],]}"},{"title":"Repositories","date":"2019-10-30T16:46:16.340Z","updated":"2019-10-30T16:46:16.340Z","comments":false,"path":"repository/index.html","permalink":"https://linuxops.fun/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-10-30T16:46:16.340Z","updated":"2019-10-30T16:46:16.340Z","comments":false,"path":"categories/index.html","permalink":"https://linuxops.fun/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-30T16:46:16.340Z","updated":"2019-10-30T16:46:16.340Z","comments":false,"path":"tags/index.html","permalink":"https://linuxops.fun/tags/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-10-30T16:46:16.340Z","updated":"2019-10-30T16:46:16.340Z","comments":false,"path":"books/index.html","permalink":"https://linuxops.fun/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-10-30T16:46:16.340Z","updated":"2019-10-30T16:46:16.340Z","comments":true,"path":"links/index.html","permalink":"https://linuxops.fun/links/index.html","excerpt":"","text":""}],"posts":[{"title":"CentOS7部署Docker-Harbor1.10.0镜像仓库","slug":"CentOS7部署Docker-Harbor1.10.0镜像仓库","date":"2019-12-10T12:45:12.000Z","updated":"2019-12-16T01:54:29.267Z","comments":true,"path":"2019/12/10/b4c9ff65.html","link":"","permalink":"https://linuxops.fun/2019/12/10/b4c9ff65.html","excerpt":"","text":"1 背景介绍由于Docker官方镜像仓库服务器是在国外，访问时速度比较慢，国内的网易蜂巢等镜像仓库又无法创建私有的镜像仓库，根据公司业务的创建的镜像不可能存放在公开的镜像仓库上；因此想通过搭建私有的镜像仓库用于存储公司业务创建的镜像，目前vmware公司开源的Harbor仓库是国内首选的私有镜像仓库，本文将使用Harbor进行部署安装。 2 软件需求 2.1 官方建议Harbor安装底层需求Python需要使用2.7或更高版本Docker引擎需要使用1.10或更高版本Docker Compose需要使用1.6.0或更高版本 2.2 本文系统和软件版本System version: CentOS Linux release 7.7.1908 (Core)Python version: Python 2.7.5（CentOS7系统默认2.7以上）Docker version: Docker version 19.03.5, build 633a0eaDocker-compose version: docker-compose version 1.25.0, build 0a186604Harbor version: v1.10.0 3 部署Harbor 3.1 安装底层依赖(1) 安装python2.7.5默认CentOS7以上的操作系统自带python2.7以上的版本，若是其他版本的操作系统，请自行Google解决安装。(2) 安装docker-ce19.03.5更新系统到最新版并重启生效12yum update -yreboot关闭防火墙firewalld和selinux1234systemctl stop firewalldsystemctl disable firewalldsed -i &apos;s#SELINUX=enforcing#SELINUX=disabled#g&apos; /etc/selinux/configsetenforce 0安装iptables并启动12345yum install -y iptables-servicessystemctl start iptablessystemctl enable iptablesiptables -Fservice iptables save使用rpm包方式安装docker-ce，使用以下网址下载docker-ce对应版本的rpm安装包和依赖组件包下载网址：https://download.docker.com/linux/centos/7/x86_64/stable/Packages/12345678910mkdir /opt/dockercd /opt/dockerwget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpmwget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-cli-19.03.5-3.el7.x86_64.rpmwget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-19.03.5-3.el7.x86_64.rpmyum install -y containerd.io-1.2.6-3.3.el7.x86_64.rpmyum install -y docker-ce-cli-19.03.5-3.el7.x86_64.rpmyum install -y docker-ce-19.03.5-3.el7.x86_64.rpm启动dockerd进程12systemctl start dockersystemctl enable docker验证docker是否正常安装并启动1docker run hello-world(3) 安装docker-compose1.25.0下载对应系统版本的docker-compose可执行文件放置到系统环境变量/usr/local/bin下，然后赋予可执行权限下载网址：https://github.com/docker/compose/releases12345cd /opt/dockerwget https://github.com/docker/compose/releases/download/1.25.0/docker-compose-Linux-x86_64cp -a docker-compose-Linux-x86_64 /usr/local/bin/docker-composecd /usr/local/bin/chmod +x docker-compose验证docker-compose是否安装成功1docker-compose -v 3.2 安装Harborharbor官方上提供offline和online两个版本，其中offline是带有底层镜像的离线版；online是不包含镜像的在线版，安装的时候会自动去官网拉取镜像；本文建议下载offline版本，减少安装时拉取镜像的时间（网速太慢）。Harbor官方下载地址：https://github.com/vmware/harbor/releases下载并解压harbor软件包1234cd /opt/dockerwget https://github.com/goharbor/harbor/releases/download/v1.10.0/harbor-offline-installer-v1.10.0.tgztar xf harbor-offline-installer-v1.10.0.tgzmv harbor /usr/local配置harbor.yml文件1234567891011121314151617181920212223cd /usr/local/harborvim harbor.yml#必选参数#set hostnamehostname: hub.itunion.com #目标的主机名或者完全限定域名# http related confighttp: # port for http, default is 80. If https enabled, this port will redirect to https port port: 80# https related confighttps: # https port for harbor, default is 443 port: 443 # The path of cert and key files for nginx certificate: /data/cert/service.crt private_key: /data/cert/service.key# Harbor DB configurationdatabase: # The password for the root user of Harbor DB. Change this before any production use. password: root123为Harbor创建https服务端证书和密钥123456789101112131415161718192021222324252627282930313233343536373839mkdir -p /data/certcd /data/cert#获取CA证书openssl genrsa -out ca.key 4096#获取CA证书密钥，其中CN的值为你要申请证书的域名（hub.itunion.com换成你的域名）openssl req -x509 -new -nodes -sha512 -days 3650 \\ -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=itunion/OU=Personal/CN=hub.itunion.com&quot; \\ -key ca.key \\ -out ca.crt#创建服务端证书密钥openssl genrsa -out service.key 4096#生成服务端证书申请文件，其中CN的值为你要申请证书的域名（hub.itunion.com换成你的域名）openssl req -sha512 -new \\ -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=itunion/OU=Personal/CN=hub.itunion.com&quot; \\ -key service.key \\ -out service.csr#生成注册表主机证书cat &gt; v3.ext &lt;&lt;-EOFauthorityKeyIdentifier=keyid,issuerbasicConstraints=CA:FALSEkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEnciphermentextendedKeyUsage = serverAuthsubjectAltName = @alt_names[alt_names]DNS.1=hub.itunion.comDNS.2=hub.itunionDNS.3=hostnameEOF#通过CA证书密钥和服务端证书申请文件生成服务端证书openssl x509 -req -sha512 -days 3650 \\ -extfile v3.ext \\ -CA ca.crt -CAkey ca.key -CAcreateserial \\ -in service.csr \\ -out service.crt为Docker配置服务端证书、密钥和CA证书12345#将服务端证书service.crt转换为service.certopenssl x509 -inform PEM -in service.crt -out service.cert#创建docker存放服务端证书的目录并复制自定义证书、密钥和CA证书到指定目录下，该目录hub.itunion.com和harbor.yml配置文件中的hostname必须一致mkdir -p /etc/docker/certs.d/hub.itunion.comcp service.cert service.key ca.crt /etc/docker/certs.d/hub.itunion.com运行harbor安装脚本12cd /usr/local/harbor./install.sh安装完成后，返回如下图所示，表示安装成功。测试访问harbor仓库web页面以Windows为例，先配置hosts解析，编辑 C:\\Windows\\System32\\drivers\\etc\\hosts 文件，添加如下内容：注：如果域名有dns解析，这一步可以省略1192.168.1.222 hub.itunion.com浏览器输入https://hub.itunion.com测试访问（将hub.itunion.com更改为你的harbor.yml配置文件中的主机名）,其中管理员默认用户名为admin，默认密码为Harbor12345，如下图所示：附：停止或启动harbor仓库命令123cd /usr/local/harbor #切换到harbor安装目录下docker-compose stop #停止harbor仓库docker-compose up -d #后台启动harbor仓库 4 客户端配置并测试私有仓库配置hosts解析以CentOS系统为例，修改/etc/hosts配置文件，执行以下命令，如下所示：注：如果域名有dns解析，这一步可以省略1echo &apos;192.168.1.221 hub.itunion.com&apos; &gt;&gt;/etc/hosts设置私有镜像仓库地址1234vim /etc/docker/daemon.json&#123; &quot;insecure-registries&quot;:[&quot;hub.itunion.com&quot;]&#125;重新加载配置并重启docker服务12systemctl daemon-reloadsystemctl restart docker下载测试镜像1docker pull hello-world给镜像重新打标签1docker tag hello-world:latest hub.itunion.com/base/hello-world:v1.0注：其中 hello-world:latest 为源镜像名:版本号hub.itunion.com/base/hello-world:v1.0 为目标仓库地址/仓库名/镜像名:版本号登录私有镜像仓库上传镜像12docker login https://hub.itunion.com #需要输入仓库的用户名和密码docker push hub.itunion.com/base/hello-world:v1.0 #推送到私有仓库的镜像登录harbor仓库web页面查看上传的镜像，如下图所示，镜像上传成功。","categories":[{"name":"Docker","slug":"Docker","permalink":"https://linuxops.fun/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linuxops.fun/tags/Docker/"}]},{"title":"CentOS7部署Docker-Harbor1.7.5镜像仓库","slug":"CentOS7部署Docker-Harbor1.7.5镜像仓库","date":"2019-01-08T12:10:12.000Z","updated":"2019-12-16T01:54:09.024Z","comments":true,"path":"2019/01/08/c731392c.html","link":"","permalink":"https://linuxops.fun/2019/01/08/c731392c.html","excerpt":"","text":"1 背景介绍由于Docker官方镜像仓库服务器是在国外，访问时速度比较慢，国内的网易蜂巢等镜像仓库又无法创建私有的镜像仓库，根据公司业务的创建的镜像不可能存放在公开的镜像仓库上；因此想通过搭建私有的镜像仓库用于存储公司业务创建的镜像，目前vmware公司开源的Harbor仓库是国内首选的私有镜像仓库，本文将使用Harbor进行部署安装。 2 软件需求 2.1 官方建议Harbor安装底层需求Python需要使用2.7或更高版本Docker引擎需要使用1.10或更高版本Docker Compose需要使用1.6.0或更高版本 2.2 本文系统和软件版本System version: CentOS Linux release 7.7.1908 (Core)Python version: Python 2.7.5（CentOS7系统默认2.7以上）Docker version: Docker version 19.03.5, build 633a0eaDocker-compose version: docker-compose version 1.25.0, build 0a186604Harbor version: v1.7.5 3 部署Harbor 3.1 安装底层依赖(1) 安装python2.7.5默认CentOS7以上的操作系统自带python2.7以上的版本，若是其他版本的操作系统，请自行Google解决安装。(2) 安装docker-ce19.03.5更新系统到最新版并重启生效12yum update -yreboot关闭防火墙firewalld和selinux1234systemctl stop firewalldsystemctl disable firewalldsed -i &apos;s#SELINUX=enforcing#SELINUX=disabled#g&apos; /etc/selinux/configsetenforce 0安装iptables并启动12345yum install -y iptables-servicessystemctl start iptablessystemctl enable iptablesiptables -Fservice iptables save使用rpm包方式安装docker-ce，使用以下网址下载docker-ce对应版本的rpm安装包和依赖组件包下载网址：https://download.docker.com/linux/centos/7/x86_64/stable/Packages/12345678910mkdir /opt/dockercd /opt/dockerwget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpmwget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-cli-19.03.5-3.el7.x86_64.rpmwget https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-19.03.5-3.el7.x86_64.rpmyum install -y containerd.io-1.2.6-3.3.el7.x86_64.rpmyum install -y docker-ce-cli-19.03.5-3.el7.x86_64.rpmyum install -y docker-ce-19.03.5-3.el7.x86_64.rpm启动dockerd进程12systemctl start dockersystemctl enable docker验证docker是否正常安装并启动1docker run hello-world(3) 安装docker-compose1.25.0下载对应系统版本的docker-compose可执行文件放置到系统环境变量/usr/local/bin下，然后赋予可执行权限下载网址：https://github.com/docker/compose/releases12345cd /opt/dockerwget https://github.com/docker/compose/releases/download/1.25.0/docker-compose-Linux-x86_64cp -a docker-compose-Linux-x86_64 /usr/local/bin/docker-composecd /usr/local/bin/chmod +x docker-compose验证docker-compose是否安装成功1docker-compose -v 3.2 安装Harborharbor官方上提供offline和online两个版本，其中offline是带有底层镜像的离线版；online是不包含镜像的在线版，安装的时候会自动去官网拉取镜像；本文建议下载offline版本，减少安装时拉取镜像的时间（网速太慢）。Harbor官方下载地址：https://github.com/vmware/harbor/releases下载并解压harbor软件包1234cd /opt/dockerwget https://storage.googleapis.com/harbor-releases/release-1.7.0/harbor-offline-installer-v1.7.5.tgztar xf harbor-offline-installer-v1.7.5.tgzmv harbor /usr/local配置harbor.cfg文件1234567891011cd /usr/local/harborvim harbor.cfg#必选参数hostname: hub.opsunion.com #目标的主机名或者完全限定域名ui_url_protocol: https #默认为http，docker官方hub使用https，此处建议和官方一致更改为httpsdb_password: root123 #用于db_auth的MySQL数据库的根密码。更改此密码进行任何生产用途max_job_workers: 3 #默认值为3，复制镜像到其他仓库时允许采用的最大线程数customize_crt: on #默认为on，此属性打开时，prepare脚本将为注册表令牌的生成/验证创建私钥和根证书ssl_cert: /data/cert/server.crt #SSL证书的路径，仅当协议设置为https时才应用ssl_cert_key: /data/cert/server.key #SSL密钥的路径，仅当协议设置为https时才应用secretkey_path: /data #用于在复制策略中加密或解密远程注册表的密码的密钥路径创建https服务端证书和密钥12345678mkdir -p /data/certcd /data/certopenssl genrsa -des3 -out server.key 2048 #生成2048位的证书加密私钥，需要设置密钥的密码openssl req -new -key server.key -out server.csr #生成证书的申请文件，需要输入前面设置的密钥密码，并且Common Name字段输入你要添加证书的域名hub.opsunion.com，即harbor.cfg配置文件中的主机名cp server.key server.key.org #备份证书私钥openssl rsa -in server.key.org -out server.key #去除证书密钥的密码，需要输入前面设置的密码openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt #生成证书运行harbor安装脚本12cd /usr/local/harbor./install.sh测试访问harbor仓库web页面以Windows为例，先配置hosts解析，编辑 C:\\Windows\\System32\\drivers\\etc\\hosts 文件，添加如下内容：注：如果域名有dns解析，这一步可以省略1192.168.1.222 hub.opsunion.com浏览器输入https://hub.opsunion.com测试访问（将hub.opsunion.com更改为你的harbor.cfg配置文件中的主机名），其中管理员默认用户名为admin，默认密码为Harbor12345，如下图所示：附：停止或启动harbor仓库命令123cd /usr/local/harbor #切换到harbor安装目录下docker-compose stop #停止harbor仓库docker-compose up -d #后台启动harbor仓库 4 客户端配置并测试私有仓库配置hosts解析以CentOS系统为例，修改/etc/hosts配置文件，执行以下命令，如下所示：注：如果域名有dns解析，这一步可以省略1echo &apos;192.168.1.222 hub.opsunion.com&apos; &gt;&gt;/etc/hosts设置私有镜像仓库地址1234vim /etc/docker/daemon.json&#123; &quot;insecure-registries&quot;:[&quot;hub.opsunion.com&quot;]&#125;重新加载配置并重启docker服务12systemctl daemon-reloadsystemctl restart docker下载测试镜像1docker pull hello-world给镜像重新打标签1docker tag hello-world:latest hub.opsunion.com/base/hello-world:v1.0注：其中 hello-world:latest 为源镜像名:版本号hub.opsunion.com/base/hello-world:v1.0 为目标仓库地址/仓库名/镜像名:版本号登录私有镜像仓库上传镜像12docker login https://hub.opsunion.com #需要输入仓库的用户名和密码docker push hub.opsunion.com/base/hello-world:v1.0 #推送到私有仓库的镜像登录harbor仓库web页面查看上传的镜像，如下图所示，镜像上传成功。","categories":[{"name":"Docker","slug":"Docker","permalink":"https://linuxops.fun/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://linuxops.fun/tags/Docker/"}]},{"title":"Ubuntu系统启动失败操作指南","slug":"Ubuntu18系统启动失败操作指南","date":"2018-06-12T11:31:12.000Z","updated":"2019-12-16T01:41:03.576Z","comments":true,"path":"2018/06/12/e83114b.html","link":"","permalink":"https://linuxops.fun/2018/06/12/e83114b.html","excerpt":"","text":"系统启动失败后，启动机器测试以下两种模式是否可以启动。 在 Ubuntu 18.04 LTS 中进入救援模式启动你的 Ubuntu 系统。出现 Grub 菜单时，选择第一条并按下 e 进行编辑。如果你没有看到 Grub 菜单，只需在 BIOS 的 logo 消失后立即按下 ESC 键。找到以单词 linux 开头的行，并在该行的末尾添加以下内容（要到达末尾，只需按下 Ctrl+e 或使用 End 键或左右箭头键）：1systemd.unit=rescue.target添加完成后，只需按下 Ctrl+x 或 F10 即可继续启动救援模式。几秒钟后，你将以 root 用户身份进入救援模式（单用户模式）。以下是 Ubuntu 18.04 LTS 服务器版中救援模式的样子：接下来，输入以下命令将根 （/） 文件系统重新挂载成读/写模式。1mount -n -o remount,rw / 启动到紧急模式将 Ubuntu 引导到紧急模式与上述方法相同。你只需在编辑 Grub 菜单时将 systemd.unit=rescue.target 替换为 systemd.unit=emergency.target 即可。添加 systemd.unit=emergency.target 后，按下 Ctrl+x 或 F10 继续启动到紧急模式。最后，你可以使用以下命令将根文件系统重新挂载成读/写模式：1mount -n -o remount,rw / 在救援模式和紧急模式之间切换如果你处于救援模式，则不必像上面提到的那样编辑 Grub 条目。相反，只需输入以下命令即可立即切换到紧急模式：1systemctl emergency同样，要从紧急模式切换到救援模式，请输入：1systemctl rescue","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://linuxops.fun/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://linuxops.fun/tags/Ubuntu/"}]},{"title":"如何选型一个合适的框架-分布式任务调度框架","slug":"如何选型一个合适的框架-分布式任务调度框架","date":"2018-01-10T10:16:12.000Z","updated":"2019-12-16T01:41:04.659Z","comments":true,"path":"2018/01/10/f959918a.html","link":"","permalink":"https://linuxops.fun/2018/01/10/f959918a.html","excerpt":"","text":"1.背景定时任务是大家再开发中一个不可避免的业务，比如在一些电商系统中可能会定时给用户发送生日券，一些对账系统中可能会定时去对账。大概再很久以前每个服务可能就一台机器，再这台机器上直接搞个Timerschedule基本上就能满足我们的业务需求，但是随着时代的变迁，单台机器已经远远不能满足我们的需要，这个时候我们可能需要10台，20台甚至更多机器来运行我们的业务，接受我们的流量，这就是我们所说的横向扩展。但是这里就有个问题，这么多台机器如果还用我们的Timerschedule去做会发生什么呢？在上面的电商系统中有可能会给某个用户发很多张生日券，对公司造成很多损失，所以我们需要一些其他方法，让定时任务在多台机器上只执行一次。这里想问下大家在没有了解过或使用过分布式任务调度框架之前，大家是如何做定时任务的呢？在Spring项目中大家肯定都知道Spring-Scheduler，只需要在Spring中的bean的对应方法上加上@Scheduler注解即可完成我们的定时任务，但是光是用这个注解还远远不能保证定时任务执行多次，我们需要一些其他手段的保证，一般来说方法可能不外乎下面几种（都是基于Spring的项目来说）：一台机器，我们可以将一些不太重要的定时任务，可以使用一个专门的服务台承载，然后使用单机跑，就算挂了只要我们再可接受的时间之内将其恢复，我们的业务也不会受到影响。多台机器，加分布式锁，只要我们执行任务的时候首先获取一把分布式锁，如果获取失败那么久证明有其他服务已经再运行，如果获取成功那么证明没有服务在运行定时任务，那么就可以执行。多台机器，利用ZooKeeper对Leader机器执行定时任务，有很多业务已经使用了ZK，那么执行定时任务的时候判断自己是否是Leader，如果不是则不执行，如果是则执行业务逻辑，这样也能达到我们的目的。目前我们公司做定时任务也是使用的上面三种方法，在业务初期使用这些方法基本也能大体满足，但是随着时间的迁移，我们遇到的问题越来越多，这里和大家分享一下：首先是单机问题，如何划分一个业务不是很重要，这一块本来就比较复杂，有可能每个人都说自己的业务都重要，其次是如果单机挂了 这个挂有可能是宕机，有可能是其他的一些情况，这个时间如何能保证我们再可接受的范围之间恢复，这些都是难点。目前我们使用定时任务的时候，如果想让它马上执行一次，这个时候可能就需要额外再写一个Rest接口或者再另外写一个单独的Job。还有个是我们需要更改定时任务执行时间，比如现在有个需求是从每12个小时执行一次变成每6小时执行一次，我们又得修改代码，提交pr，然后打包上线，只是修改一个时间又得花费我们很多时间。无法暂停我们的定时任务，当我们的定时任务可能出现一些问题，比如一些定时报警的需求，当报警突然变得很多，这个时候需要暂停一下让其停止发送报警，这个时候可能我们可以用一些分布式配置的开关去做，再逻辑中判断定时任务开关是否打开，然后来做。这样做虽然也比较简单，但是我们这样需要新添加一些与任务无关的逻辑。缺少对定时任务的监控，任务失败之后开发人员无从得知，有人说不是有Error日志吗，如果一个Error日志就一次报警那你们的服务能受得了吗，一般来说连续几次Error才会触发报警，而我们定时任务的周期性的特性是不容易触发连续的Error。当然还有一些或多或少的小问题这里就不一一列举了，如果大家有这种经历可以自己慢慢体会发现。 2. 调研的基本原则上面第一章讲了我们框架的原因，不论你要引入或改进什么，都需要原因，因为做任何事都有成本，我经常看到一些很小的项目就开始搞引入消息队列，或者分布式事务等等，这样做反而是本末倒置，比如可能有一些博客系统就搞个消息队列削峰减流，这样做有可能还没有同步调用来得快。当我们有了原因之后，就可以着手做一些调研或者技术方案的设计。这里我讲一下我的调研框架一些基本原则，如果大家以后有类似的调研框架的需求都可以往这个里面来套。简单-对开发者接入简单，对使用者使用简单。丰富的文档，有很多开源的项目文档少之又少，当然还有一些开源项目只有英文文档，如果你英文不是很行，那可能需要考虑中文居多的文档。有管理界面，很方便执行操作和统计数据。支持主流框架：比如Spring,Springboot等，当然这个至少要支持你们业务中的主流框架。框架轻量级，方便根据自己的需求进行定制化。高性能，高可靠，高可用：不能让框架成为业务中的瓶颈。代码更新频率和社区使用情况：使用的公司越多证明其越受更多人的喜爱，代码更新频率越高证明出现问题就会越少，最好是由大厂开源并且维护。多语言需求：如果在你们业务中有多语言需求，比如你们公司用的开发语言很多，都需要调度框架那么你需要使用多语言支持。比如Rpc支持多语言的代表就是Thrift。能否解决当前的痛点：这个是最重要的，如果连你问题都解决不了那使用这个还有什么意义呢？当我们有了上述的几大原则之后，我们接下来可以进入调研。 3.调研框架 3.1 TBSchedule一般调研Java系的一些框架，可以先看看阿里是不是有开源的，毕竟最近这几年阿里在开源这一块做得是非常的好，再网上搜索到阿里在12年开源了一个调度框架叫TBSchedule，现在再去搜索代码，发现已经人走茶凉，代码都被清理干净了。当然还有一个个人项目将其Fork出来再不断维护，但是使用者实在是少这里就不说明了。 github地址：https://github.com/taobao/TBSchedule 3.2 elastic-jobelastic-Job 是当当开源的一个分布式调度解决方案，由两个相互独立的子项目 Elastic-Job-Lite 和 Elastic-Job-Cloud 组成。定位为轻量级无中心化解决方案，使用 jar 包的形式提供分布式任务的协调服务。支持分布式调度协调、弹性扩容缩容、失效转移、错过执行作业重触发、并行调度、自诊断和修复等等功能特性。这个框架大概在2年前很火，当时使用的公司很多，想必很多人也听过了，但是很可惜现在已经不在维护了，代码已经有2年没有更新了，这里违反了更新频率的原则，如果出现问题可能都没什么人帮助你，所以我们并不是很推荐使用。github地址：https://github.com/elasticjob/elastic-job-lite 3.3 一些比较小众的在网上有一些比较小众的github star很少，更新频率也很少： Uncode-Schedule，LTS,openCron等等，这些也不符合我们的原则，都不予以考虑 3.4 XXL-JOB由于分布式定时任务现在还没有基金会比如CNCF,Apache等，抉择起来可能不是那么难。不像消息队列再Apache里面就有好几个：Kafka、rocketmq、plusar等等，每一个的社区都很庞大，可能选择是比较困难的。那么我们基本就还剩下两个选择，一个是自研，这种任务调度框架，再研发的困难程度上是远远比不上消息队列的研发，所以其实很多公司都选择了自研，比如：美团的Crane这些。但是对于一些消息队列这些复杂的中间件可能会选择二次开发，比如美团的mafka就是基于kafka二次开发，滴滴的DDMQ也是基于Rocketmq。而我们目前如果选择自研再资源上来说是明显不够的，这里我们还是使用的是二次开发框架的策略。当然这里还剩下一个XXL-Job：www.xuxueli.com/xxl-job 的选择，其基本符合我们的原则，目前代码也在持续更新，issue作者也在积极的回复，使用的公司也有200多家,其中包括之前的点评，同时其他的原则也很符合。一般来说当你决定选择某个框架的时候需要详细的列举一下优点，好让其他人得以信服。xxl-job有下面一些特点：简单：支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手；动态：支持动态修改任务状态、启动/停止任务，以及终止运行中任务，即时生效；调度中心HA（中心式）：调度采用中心式设计，“调度中心”自研调度组件并支持集群部署，可保证调度中心HA；执行器HA（分布式）：任务分布式执行，任务&quot;执行器&quot;支持集群部署，可保证任务执行HA；注册中心: 执行器会周期性自动注册任务, 调度中心将会自动发现注册的任务并触发执行。同时，也支持手动录入执行器地址；弹性扩容缩容：一旦有新执行器机器上线或者下线，下次调度时将会重新分配任务；路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等；故障转移：任务路由策略选择&quot;故障转移&quot;情况下，如果执行器集群中某一台机器故障，将会自动Failover切换到一台正常的执行器发送调度请求。阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行（默认）、丢弃后续调度、覆盖之前调度；事件触发：除了&quot;Cron方式&quot;和&quot;任务依赖方式&quot;触发任务执行之外，支持基于事件的触发任务方式。调度中心提供触发任务单次执行的API服务，可根据业务事件灵活触发。任务进度监控：支持实时监控任务进度；Rolling实时日志：支持在线查看调度结果，并且支持以Rolling方式实时查看执行器输出的完整的执行日志基本上上面的一些特点都是我们业务中所需要的，所以这里最后选择了XXL-JOB 4.总结俗话说：授人以鱼不如授人以渔，之前的文章每次都是介绍某某框架，这一次我偏向于介绍我是如何选择的这款框架，让大家再以后调研的过程中也可以按照这个思路，如果说你也有好的并且不同的调研思路，欢迎留言或者加群交流。当然一般调研完毕之后，作为一个调研人如果你不弄清楚这个框架的源码和实现原理，那么就是一个不合格的调研人，所以下一篇文章我会详细的介绍XXL-Job的实现原理。","categories":[{"name":"技术调研","slug":"技术调研","permalink":"https://linuxops.fun/categories/技术调研/"}],"tags":[{"name":"技术调研","slug":"技术调研","permalink":"https://linuxops.fun/tags/技术调研/"}]},{"title":"Rabbitmq重启服务后登录用户丢失问题","slug":"Rabbitmq重启导致控制台配置的用户丢失","date":"2017-09-10T10:16:12.000Z","updated":"2019-12-16T01:41:03.574Z","comments":true,"path":"2017/09/10/e8c21973.html","link":"","permalink":"https://linuxops.fun/2017/09/10/e8c21973.html","excerpt":"","text":"Rabbitmq在命令行创建的用户，当Raqbbitmq服务重启后会丢失，需要重新创建，只要根据以下两个步骤更改对应的两个配置文件，就可以实现重启Rabbitmq服务后用户保留。(1) 修改Rabbitmq的配置文件 /etc/rabbitmq/rabbitmq-env.conf ，增加以下这行内容：1NODENAME=rabbit@test-rabitmq注：NODENAME=rabbit@为配置文件的字段格式，test-rabitmq为服务器的主机名，需要将test-rabitmq更改为你的服务器对应的主机名。(2) 修改系统的配置文件/etc/hosts，增加以下这行内容：1127.0.0.1 test-rabitmq注：127.0.0.1为服务器的IP地址，test-rabitmq为服务器的主机名，只需要根据自己的服务器修改成自己服务器对应的主机名hostname即可。完成以上两个步骤后，在命令行增加Rabbitmq的用户，并设置用户的权限和角色，执行以下命令：123# rabbitmqctl add_user Username Password # 新增用户# rabbitmqctl set_user_tags User Tag # 设置用户角色# rabbitmqctl set_permissions [-p vhostpath] username regexp regexp regexp # 设置用户权限最后，重启Rabbitmq服务，在命令行界面查看当前用户列表 ，执行以下命令：1# rabbitmqctl list_users返回结果显示，刚才在命令行中新建的用户 Username 还存在，则表示重启Rabbitmq服务后，用户保留成功。","categories":[{"name":"Middleware","slug":"Middleware","permalink":"https://linuxops.fun/categories/Middleware/"}],"tags":[]},{"title":"Stunnel隐藏OpenVPN流量实现科学上网","slug":"Stunnel隐藏OpenVPN流量实现科学上网","date":"2017-05-31T13:15:12.000Z","updated":"2019-12-16T01:41:03.567Z","comments":true,"path":"2017/05/31/8a64b922.html","link":"","permalink":"https://linuxops.fun/2017/05/31/8a64b922.html","excerpt":"","text":"简介众所周知的原因，在海外直接搭建 OpenVPN 根本无法使用（TCP 模式），或者用段时间就被墙了（UDP 模式）。本文主要介绍如何通过 Stunnel 隐藏 OpenVPN 流量，使其看起来像普通的 SSL 协议传输，从而绕过 gfw。Stunnel 分为客户端和服务端，客户端负责接收用户 OpenVPN 客户端流量并转化成 SSL 协议加密数据包，然后转发给 Stunnel 服务端，实现 SSL 协议数据传输，服务端然后将流量转化成 OpenVPN 流量传输给 OpenVPN 服务端。因此我们可以在国内搭 Stunnel 客户端，国外搭 Stunnel 服务端。OpenVPN + Stunnel 整体架构如下： Stunnel 隐藏 OpenVPN 流量具体过程 1. 搭建 OpenVPN 服务端关于 OpenVPN 的搭建及使用在这里不多说了，可以查看我之前的博文。这里要说明的是，Stunnel 不支持 udp 流量转换，所以 OpenVPN 需要以 TCP 模式运行。下面为 OpenVPN 服务端 TCP 模式的 server.conf 配置示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176##################################################################### 针对多客户端的OpenVPN 2.4的服务器端配置文件示例## 本文件用于多客户端&lt;-&gt;单服务器端的OpenVPN服务器端配置## OpenVPN也支持单机&lt;-&gt;单机的配置(更多信息请查看网站上的示例页面)## 该配置支持Windows或者Linux/BSD系统。此外，在Windows上，记得将路径加上双引号，# 并且使用两个反斜杠，例如：&quot;C:\\\\Program Files\\\\OpenVPN\\\\config\\\\foo.key&quot;## &apos;#&apos; or &apos;;&apos;开头的均为注释内容#################################################################### OpenVPN监听本机的哪些IP地址，该命令是可选的，如果不设置，则默认监听本机的所有IP地址;local a.b.c.d# 监听的端口号port 1194# 服务端用的协议tcp/udp，udp能快点，所以我选择udpproto udp# 默认使用路由模式，tap是桥接模式# 指定OpenVPN创建的通信隧道类型# &quot;dev tun&quot;将会创建一个路由IP隧道# &quot;dev tap&quot;将会创建一个以太网隧道# 如果你是以太网桥接模式，并且提前创建了一个名为&quot;tap0&quot;的与以太网接口进行桥接的虚拟接口，则你可以使用&quot;dev tap0&quot;# 如果你想控制VPN的访问策略，你必须为TUN/TAP接口创建防火墙规则# 在非Windows系统中，你可以给出明确的单位编号(unit number)，例如&quot;tun0&quot;# 在Windows中，你也可以使用&quot;dev-node&quot;# 在多数系统中，除非你部分禁用或者完全禁用了TUN/TAP接口的防火墙，否则VPN将不起作用;dev tapdev tun# 如果你想配置多个隧道，你需要用到网络连接面板中TAP-Win32适配器的名称例如&quot;MyTap&quot;)# 在XP SP2或更高版本的系统中，你可能需要有选择地禁用掉针对TAP适配器的防火墙# 通常情况下，非Windows系统则不需要该指令。;dev-node MyTap# CA根证书路径ca /etc/openvpn/server/certs/ca.crt# OpenVPN服务端证书路径cert /etc/openvpn/server/certs/server.crt# OpenVPN服务端密钥路径key /etc/openvpn/server/certs/server.key# Diffie-Hellman算法密钥文件路径dh /etc/openvpn/server/certs/dh.pem# 出于SSL/TLS之外更多的安全考虑，创建一个&quot;HMAC 防火墙&quot;可以帮助抵御DoS攻击和UDP端口淹没攻击。# 你可以使用以下命令来生成：# openvpn --genkey --secret ta.key# 服务器和每个客户端都需要拥有该密钥的一个拷贝。# 第二个参数在服务器端应该为&apos;。# tls-auth key，参数0可以省略，如果不省略，那么客户端配置文件相应的参数tls-auth该配成 1。如果省略，那么客户端不需要 tls-auth 配置tls-auth /etc/openvpn/server/certs/ta.key 0# 选择一个密码加密算法。# 该配置项也必须复制到每个客户端配置文件中。;cipher BF-CBC # Blowfish (默认);cipher AES--CBC # AES;cipher DES-EDE3-CBC # Triple-DES# 该网段为OpenVPN虚拟网卡网段，不要和内网网段冲突即可。OpenVPN默认使用10.8.0.0/24网段为客户端分配IP地址server 10.8.0.0 255.255.255.0# 指定用于记录客户端和虚拟IP地址的关联关系的文件，当重启OpenVPN时，再次连接的客户端将分配到与上一次分配相同的虚拟IP地址ifconfig-pool-persist ipp.txt# 主DNS服务器配置，可以根据需要指定其他DNSpush &quot;dhcp-option DNS 8.8.8.8&quot;# 备DNS服务器配置，可以根据需要指定其他DNSpush &quot;dhcp-option DNS 8.8.4.4&quot;# 推送路由信息到客户端，告诉客户端连接172.18.0.0/16这个网段的流量通过openvpn转发，以允许客户端能够连接到服务端背后的其他私有子网;# 其中172.18.0.0/16网段是你要连接的openvpn服务端的私网ip地址段，类似于局部代理;# 使客户端机器在浏览器访问其他正常网页时由本地网卡出去，从而达到不影响本地网络的网速。push &quot;route 172.18.0.0 255.255.0.0&quot;# 客户端所有流量都通过open VPN虚拟网卡转发，类似于全局代理，这样客户端在浏览器访问其他正常网站时;# 也是通过OpenVPN虚拟网卡出去访问，会严重影响客户端访问正常网页的网速;push &quot;redirect-gateway def1&quot;# 该指令仅针对以太网桥接模式。# 首先，你必须使用操作系统的桥接能力将以太网网卡接口和TAP接口进行桥接。# 然后，你需要手动设置桥接接口的IP地址、子网掩码；# 在这里，我们假设为10.。# 最后，我们必须指定子网的一个IP范围(例如从10.8.0.50开始，到10.8.0.100结束)，以便于分配给连接的客户端。# 如果你不是以太网桥接模式，直接注释掉这行指令即可。;server-bridge 10.8.0.4 255.255.255.0 10.8.0.50 10.8.0.100# 该指令仅针对使用DHCP代理的以太网桥接模式，# 此时客户端将请求服务器端的DHCP服务器，从而获得分配给它的IP地址和DNS服务器地址。# 在此之前，你也需要先将以太网网卡接口和TAP接口进行桥接。# 注意：该指令仅用于OpenVPN客户端，并且该客户端的TAP适配器需要绑定到一个DHCP客户端上。;server-bridge# 允许一个用户多个终端连接# 如果多个客户端可能使用相同的证书/私钥文件或Common Name进行连接，那么你可以取消该指令的注释。# 建议该指令仅用于测试目的。对于生产使用环境而言，每个客户端都应该拥有自己的证书和私钥。# 如果你没有为每个客户端分别生成Common Name唯一的证书/私钥，你可以取消该行的注释(但不推荐这样做)。;duplicate-cn# keepalive指令将导致类似于ping命令的消息被来回发送，以便于服务器端和客户端知道对方何时被关闭。# 每10秒钟ping一次，如果120秒内都没有收到对方的回复，则表示远程连接已经关闭。keepalive 10 120# 在VPN连接上启用压缩。# 如果你在此处启用了该指令，那么也应该在每个客户端配置文件中启用它。comp-lzo# 允许并发连接的客户端的最大数量;max-clients# 去掉该指令的注释将允许不同的客户端之间相互&quot;可见&quot;(允许客户端之间互相访问)。# 该选项允许连接openvpn的客户端直接通讯而不经过openvpn服务端网关。# 默认情况下，客户端只能&quot;看见&quot;服务器。为了确保客户端只能看见服务器，你还可以在服务器端的TUN/TAP接口上设置适当的防火墙规则。client-to-client# 持久化选项可以尽量避免访问那些在重启之后由于用户权限降低而无法访问的某些资源。persist-keypersist-tun# OpenVPN进程启动用户，OpenVPN用户在安装完openvpn安装包后就自动生成了# 在完成初始化工作之后，降低OpenVPN守护进程的权限是个不错的主意。# 该指令仅限于非Windows系统中使用。user openvpngroup openvpn# 默认情况下，日志消息将写入syslog(在Windows系统中，如果以服务方式运行，日志消息将写入OpenVPN安装目录的log文件夹中)。# 你可以使用log或者log-append来改变这种默认情况。# &quot;log&quot;方式在每次启动时都会清空之前的日志文件。# &quot;log-append&quot;这是在之前的日志内容后进行追加。# 你可以使用两种方式之一(但不要同时使用)。;log /var/log/openvpn/openvpn.loglog-append /var/log/openvpn/openvpn.log# 输出一个简短的状态文件，用于显示当前的连接状态，该文件每分钟都会清空并重写一次。status /var/log/openvpn/openvpn-status.log# 为日志文件设置适当的冗余级别(~)。冗余级别越高，输出的信息越详细。# 0 表示静默运行，只记录致命错误。# 4 表示合理的常规用法。# 5 可以帮助调试连接错误。# 9 表示极度冗余，输出非常详细的日志信息。verb 3# 重复信息的沉默度。# 相同类别的信息只有前20条会输出到日志文件中。;mute# 当服务端重新启动时，通知客户端可以自动重新连接。# 当proto使用tcp时，需要注销该行配置，否则会导致服务端无法启动explicit-exit-notify 1# 为指定的客户端分配指定的IP地址，或者客户端背后也有一个私有子网想要访问VPN，# 那么你可以针对该客户端的配置文件使用ccd子目录。# (简而言之，就是允许客户端所在的局域网成员也能够访问VPN) # 举个例子：假设有个Common Name为/255.255.255.248。# 首先，你需要去掉下面两行指令的注释：;client-config-dir ccd;route 192.168.40.128 255.255.255.248# 然后创建一个文件ccd/Thelonious，该文件的内容为：# iroute 192.168.40.128 255.255.255.248# 这样客户端所在的局域网就可以访问VPN了。# 注意，这个指令只能在你是基于路由、而不是基于桥接的模式下才能生效。# 比如，你使用了&quot;dev tun&quot;和&quot;server&quot;指令。# 再举个例子：假设你想给Thelonious分配一个固定的IP地址10.。# 首先，你需要去掉下面两行指令的注释：;client-config-dir ccd;route 10.9.0.0 255.255.255.252# 然后在文件ccd/Thelonious中添加如下指令：# ifconfig-push 10.9.0.1 10.9.0.2## 如果你想要为不同群组的客户端启用不同的防火墙访问策略，你可以使用如下两种方法：# # ()运行多个OpenVPN守护进程，每个进程对应一个群组，并为每个进程(群组)启用适当的防火墙规则。# # () (进阶)创建一个脚本来动态地修改响应于来自不同客户的防火墙规则。# # 关于learn-address脚本的更多信息请参考官方手册页面。;learn-address ./script 2. Stunnel 服务端安装配置 安装配置 Stunnel 服务端（海外节点）安装Stunnel 服务端，执行以下命令：1234# yum -y install stunnel# cd /etc/stunnel# openssl req -new -x509 -days 3650 -nodes -out stunnel.pem -keyout stunnel.pem# chmod 600 /etc/stunnel/stunnel.pem修改Stunnel 服务端的配置文件 stunnel.conf，执行以下命令：1# vim stunnel.conf # 编辑配置文件stunnel.confstunnel.conf 填入如下内容:1234567pid = /var/run/stunnel.pidoutput = /var/log/stunnel.logclient = no[openvpn]accept = 443 connect = 127.0.0.1:4001cert = /etc/stunnel/stunnel.pem说明：accept = 443 # Stunnel 服务端监听端口connect = 127.0.0.1:4001 # OpenVPN 服务端 IP 地址和端口 使用 systemd 启动 Stunnel 服务端为了管理方便，我们使用 systemd 管理 Stunnel 服务，编辑一个 systemd unit 的管理文件，执行以下命令：1# vim /lib/systemd/system/stunnel.service添加以下内容：12345678910111213141516171819[Unit]Description=SSL tunnel for network daemonsAfter=network.targetAfter=syslog.target[Install]WantedBy=multi-user.targetAlias=stunnel.target[Service]Type=forkingExecStart=/usr/bin/stunnel /etc/stunnel/stunnel.confExecStop=/usr/bin/killall -9 stunnel# Give up if ping don&apos;t get an answerTimeoutSec=600Restart=alwaysPrivateTmp=false启动 Stunnel 服务端：12systemctl start stunnel.servicesystemctl enable stunnel.service 3. Stunnel 客户端安装配置Stunnel 的客户端安装和服务器一样，同样的软件，既可以作为客户端，也可以作为服务端，只是配置不同而已。 安装配置 Stunnel 客户端（国内节点）12345678910111213yum -y install stunnelcd /etc/stunnelscp .... # 将服务端的证书 stunnel.pem 拷贝到这里chmod 600 /etc/stunnel/stunnel.pemvim stunnel.conf 填入如下内容：pid=/var/run/stunnel.pidoutput=/var/log/stunnel.logclient = yes[openvpn]accept=8443connect=stunnel_server_ip:443cert = /etc/stunnel/stunnel.pem说明：accept=8443 # Stunnel 客户端监听端口stunnel_server_ip:443 # stunnel 服务端 ip 及端口 使用 systemd 启动 Stunnel 客户端这里前面同服务端的操作过程，不再赘述。启动 Stunnel 客户端：12systemctl start stunnel.servicesystemctl enable stunnel.service 4. 使用 OpenVPN 连接 StunnelStunnel + OpenVPN 都配好后，就可以使用 OpenVPN 客户端实现科学上网了，需要注意的是 OpenVPN 客户端现在需要连接的是 Stunnel 客户端，不再是直接连接 OpenVPN 服务端。 相关文档https://github.com/Xaqron/stunnel","categories":[{"name":"CentOS","slug":"CentOS","permalink":"https://linuxops.fun/categories/CentOS/"}],"tags":[{"name":"OpenVPN","slug":"OpenVPN","permalink":"https://linuxops.fun/tags/OpenVPN/"}]},{"title":"OpenVPN使用账号密码认证方式登陆","slug":"OpenVPN使用账号密码认证方式登陆","date":"2017-05-30T12:26:12.000Z","updated":"2019-12-16T01:41:03.570Z","comments":true,"path":"2017/05/30/f6c8d148.html","link":"","permalink":"https://linuxops.fun/2017/05/30/f6c8d148.html","excerpt":"","text":"使用账号密码人认证方式方便给多人分配不同的账号和密码，多人使用更加方便鉴于上一篇文章已经在CentOS7系统上成功的搭建好 OpenVPN 了，以Windows客户端为例是直接使用证书进行连接OpenVPN服务端的，如果多人使用的话，建议改为账号+密码认证方式，这里介绍比较简单的一种方式。 服务端配置 修改服务端配置修改OpenVPN服务端配置文件server.conf，执行以下命令：1$ vim /etc/openvpn/server.conf # 打开server.conf配置文件编辑在配置文件server.conf的末尾追加下面的配置信息。1234567891011121314# use username and password login# 新加此行，开启密码验证脚本auth-user-pass-verify /etc/openvpn/checkpsw.sh via-env# 加上client-cert-not-required代表只使用用户密码方式验证登录，不加则代表需要证书和用户名密码双重验证登录client-cert-not-required# 新加此行，使用客户提供的UserName作为Common Nameusername-as-common-name# 该指令提供对OpenVPN使用外部程序和脚本的策略级别的控制。较低的 水平 值更具限制性，较高的值更宽松。级别设置 # 0- 完全不调用外部程序。# 1- （默认）仅调用内置可执行文件，例如ifconfig，ip，route或netsh。# 2- 允许调用内置的可执行文件和用户定义的脚本。# 3- 允许通过环境变量将密码传递给脚本（可能不安全）。# 特别注意如果没有这个配置项会导致服务端校验密码时无法获取到密码，导致校验失败script-security 3 增加密码验证脚本下面开始编写OpenVPN服务端验证密码的脚本checkpsw.sh，执行以下命令：1$ vim /etc/openvpn/checkpsw.shcheckpsw.sh 文件内容如下所示：123456789101112131415161718192021222324252627282930313233#!/bin/sh############################################################ checkpsw.sh (C) 2004 Mathias Sundman &lt;mathias@openvpn.se&gt;## This script will authenticate OpenVPN users against# a plain text file. The passfile should simply contain# one row per user with the username first followed by# one or more space(s) or tab(s) and then the password.###########################################################PASSFILE=&quot;/etc/openvpn/user_passwd.txt&quot;LOG_FILE=&quot;/var/log/openvpn/openvpn-login.log&quot;TIME_STAMP=`date &quot;+%Y-%m-%d %T&quot;`if [ ! -r &quot;$&#123;PASSFILE&#125;&quot; ]; then echo &quot;$&#123;TIME_STAMP&#125;: Could not open password file \\&quot;$&#123;PASSFILE&#125;\\&quot; for reading.&quot; &gt;&gt; $&#123;LOG_FILE&#125; exit 1fiCORRECT_PASSWORD=`awk &apos;!/^;/&amp;&amp;!/^#/&amp;&amp;$1==&quot;&apos;$&#123;username&#125;&apos;&quot;&#123;print $2;exit&#125;&apos; $&#123;PASSFILE&#125;`if [ &quot;$&#123;CORRECT_PASSWORD&#125;&quot; = &quot;&quot; ]; then echo &quot;$&#123;TIME_STAMP&#125;: User does not exist: username=\\&quot;$&#123;username&#125;\\&quot;, password=\\&quot;$&#123;password&#125;\\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125; exit 1fiif [ &quot;$&#123;password&#125;&quot; = &quot;$&#123;CORRECT_PASSWORD&#125;&quot; ]; then echo &quot;$&#123;TIME_STAMP&#125;: Successful authentication: username=\\&quot;$&#123;username&#125;\\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125; exit 0fiecho &quot;$&#123;TIME_STAMP&#125;: Incorrect password: username=\\&quot;$&#123;username&#125;\\&quot;, password=\\&quot;$&#123;password&#125;\\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125;exit 1为密码验证脚本checkpsw.sh添加可执行性权限，执行以下命令：1# chmod +x /etc/openvpn/checkpsw.sh 配置账号密码文件配置账号/密码文件user_passwd.txt的内容，新增账号/密码到这个文件，一行一个账号，账号密码用空格隔开：注：密码需要使用字母加数字，特殊字符等，且不能以数字开头1234567$ vim /etc/openvpn/user_passwd.txt # 编辑账号密码文件，添加以下内容eddieeo c123456@# 修改账号密码文件的访问权限，第一是为了安全起见，第二是启动OpenVPN服务端的用户（默认是openvpn用户）必须对账号密码文件具有可读权限$ cd /etc/openvpn/$ chmod 400 user_passwd.txt$ chown openvpn.openvpn user_passwd.txt重启openvpn服务1$ systemctl restart openvpn@server 客户端配置 修改客户端配置这里以 Windows 客户端为例，编辑客户端软件 OpenVPN GUI 安装路径下的config目录里名为 *.ovpn 结尾的配置文件，修改文件内容如下：123456# 注释掉客户端密钥认证方式;cert laptop.crt;key laptop.key# 新增账号/密码验证方式auth-user-pass 测试连接编辑完保存好配置文件，使用管理员身份打开客户端程序OpenVPN GUI ,尝试重新连接OpenVPN服务端，可以看到弹出登陆框，输入账号和密码进行验证，如下图所示：显示OpenVPN GUI连接状态，如下图所示，表示完成账号密码验证，此时已经连接上OpenVPN服务端了。最后使用 ping 服务端的私网地址的方式，测试连通性。 其他注意服务端配置文件 server.conf 的最后一行1script-security 3默认的级别是 2，需要修改为级别 3 ， 可以用 ps 看进程号时能看到 。如果没有这个的话，会有个很神奇的现象，就是账号可以传过来，但是密码获取不到，可以在服务端的登录日志/var/log/openvpn/openvpn-login.log 里查看日志！！！ 客户端添加账号密码文件省去手动输入账号密码如果客户端需要记住账号/密码，以Windows客户端 OpenVPN GUI 为例，可以在客户端安装路径下的config目录里修改 *.ovpn 配置文件的配置，添加指定账号密码文件login.conf （Mac客户端Tunnelblick试过不好使）1auth-user-pass login.conf然后在客户端安装路径下的config目录里新增login.conf 文件，账号密码使用换行符分隔，内容如下：12eddieeoc123456@","categories":[{"name":"CentOS","slug":"CentOS","permalink":"https://linuxops.fun/categories/CentOS/"}],"tags":[{"name":"OpenVPN","slug":"OpenVPN","permalink":"https://linuxops.fun/tags/OpenVPN/"}]},{"title":"CentOS7下搭建OpenVPN","slug":"CentOS7下搭建OpenVPN","date":"2017-05-29T12:16:12.000Z","updated":"2019-10-30T16:50:17.849Z","comments":true,"path":"2017/05/29/140cbb13.html","link":"","permalink":"https://linuxops.fun/2017/05/29/140cbb13.html","excerpt":"","text":"OpenVPN 是一个用于创建虚拟专用网络加密通道的软件包，最早是由James Yonan编写的。OpenVPN允许创建的VPN使用公开密钥、电子证书、或者用户名/密码来进行身份验证.。目前OpenVPN能在Solaris、Linux、OpenBSD、FreeBSD、NetBSD、Mac OS X与Microsoft Windows以及Android和iOS上运行，并包含了许多安全性的功能。它并不是一个基于Web的VPN软件，也不与IPsec及其他VPN软件包兼容。 OpenVPN Server/Client部署流程图搭建n VPN 服务端—&gt;添加防火墙规则：snat—&gt;启动 open VPN 服务端—&gt;创建一个用户测试连接：创建客户端 CA 证书、生成 .ovpn 配置文件、打包相关文件供客户端使用。 OpenVPN 服务端 环境准备由于不同环境及软件版本命令使用略有差异，特别是 easy-rsa 的使用在 2.0 和 3.0 的差别有点大，所以在此先说明下安装环境及相关软件版本：123System Version: CentOS7OpenVPN Version: 2.4.7Easy-rsa Version：3.0.6 安装与配置 1. 安装 openvpn、easy-rsa、iptables-services12# yum -y install epel-release # 安装第三方yum源# yum -y install openvpn easy-rsa iptables-services # 安装openvpn，easy-rsa等软件 2. 使用 easy-rsa 生成需要的证书及相关文件CA 根证书OpenVPN 服务器 ssl 证书Diffie-Hellman 算法用到的 key 2.1 将 easy-rsa 脚本复制到 /etc/openvpn/目录下，该脚本主要用来方便地生成 CA 证书和各种 key1# cp -r /usr/share/easy-rsa/ /etc/openvpn/ 2.2 跳到 easy-rsa 目录并编辑 vars 文件，添加一些生成证书时用到的变量12345678910# cd /etc/openvpn/easy-rsa/&lt;easy-rsa 版本号&gt;/ # 查看 easy-rsa 版本号：yum info easy-rsa# vim vars # 没这个文件的话新建，填写如下内容（变量值根据实际情况随便填写）: export KEY_COUNTRY=&quot;CN&quot;export KEY_PROVINCE=&quot;Guangdong Province&quot;export KEY_CITY=&quot;ShenZhen&quot;export KEY_ORG=&quot;Linuxops ORG&quot;export KEY_EMAIL=&quot;email@email.com&quot;然后执行以下命令，使vars文件的变量立即生效# source ./vars # 使变量立即生效 2.3 生成 CA 根证书12# ./easyrsa init-pki #初始化 pki 相关目录# ./easyrsa build-ca nopass #生成 CA 根证书, 需要输入 Common Name，名字随便起，然后回车。 2.4 生成 OpenVPN 服务器证书和密钥第一个参数 server 为证书名称，可以随便起，比如 ./easyrsa build-server-full openvpn nopass第二个参数 nopass 表示生成服务端密钥时不设置密码1# ./easyrsa build-server-full server nopass 2.5 生成 Diffie-Hellman 算法需要的密钥文件1# ./easyrsa gen-dh # 创建Diffie-Hellman，这可能得等一小会儿 2.6 生成 tls-auth key这个 key 主要用于防止 DoS 和 TLS 攻击，这一步其实是可选的，但为了安全还是生成一下，该文件在后面配置 OpenVPN 的配置文件时会用到。1# openvpn --genkey --secret ta.key 2.7 将上面生成的相关证书文件整理到 /etc/openvpn/server/certs123456# mkdir /etc/openvpn/server/certs &amp;&amp; cd /etc/openvpn/server/certs/# cp /etc/openvpn/easy-rsa/3/pki/dh.pem ./ # SSL 协商时 Diffie-Hellman 算法需要的 key# cp /etc/openvpn/easy-rsa/3/pki/ca.crt ./ # CA 根证书# cp /etc/openvpn/easy-rsa/3/pki/issued/server.crt ./ # OpenVPN 服务器证书# cp /etc/openvpn/easy-rsa/3/pki/private/server.key ./ # OpenVPN 服务器证书 key# cp /etc/openvpn/easy-rsa/3/ta.key ./ # 生成 tls-auth key 文件 2.8 创建 open VPN 日志目录12# mkdir -p /var/log/openvpn/# chown openvpn:openvpn /var/log/openvpn 3. 配置 OpenVPN可以从 /usr/share/doc/openvpn-&lt;openvpn 版本号&gt;/sample/sample-config-files/server.conf 复制一份 demo 到 /etc/openvpn/（openvpn 版本号查看：yum info openvpn。）然后改改，或者从头开始创建一个新的配置文件。我选择新建配置，执行以下命令新建server.conf文件12# cd /etc/openvpn # 切换到openvpn配置文件目录下# vim server.conf # 新建server.conf配置文件server.conf 文件填入如下内容，很多配置项不需要特别了解，重要的配置这里已经添加注释了，其他相关配置项想了解的话可以单击这个链接 https://community.openvpn.net/openvpn/wiki/Openvpn24ManPage注：配置文件中;开头的表示该行配置被注释， # 号后面表示该行配置的解释server.conf 文件内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176##################################################################### 针对多客户端的OpenVPN 2.4的服务器端配置文件示例## 本文件用于多客户端&lt;-&gt;单服务器端的OpenVPN服务器端配置## OpenVPN也支持单机&lt;-&gt;单机的配置(更多信息请查看网站上的示例页面)## 该配置支持Windows或者Linux/BSD系统。此外，在Windows上，记得将路径加上双引号，# 并且使用两个反斜杠，例如：&quot;C:\\\\Program Files\\\\OpenVPN\\\\config\\\\foo.key&quot;## &apos;#&apos; or &apos;;&apos;开头的均为注释内容#################################################################### OpenVPN监听本机的哪些IP地址，该命令是可选的，如果不设置，则默认监听本机的所有IP地址;local a.b.c.d# 监听的端口号port 1194# 服务端用的协议tcp/udp，udp能快点，所以我选择udpproto udp# 默认使用路由模式，tap是桥接模式# 指定OpenVPN创建的通信隧道类型# &quot;dev tun&quot;将会创建一个路由IP隧道# &quot;dev tap&quot;将会创建一个以太网隧道# 如果你是以太网桥接模式，并且提前创建了一个名为&quot;tap0&quot;的与以太网接口进行桥接的虚拟接口，则你可以使用&quot;dev tap0&quot;# 如果你想控制VPN的访问策略，你必须为TUN/TAP接口创建防火墙规则# 在非Windows系统中，你可以给出明确的单位编号(unit number)，例如&quot;tun0&quot;# 在Windows中，你也可以使用&quot;dev-node&quot;# 在多数系统中，除非你部分禁用或者完全禁用了TUN/TAP接口的防火墙，否则VPN将不起作用;dev tapdev tun# 如果你想配置多个隧道，你需要用到网络连接面板中TAP-Win32适配器的名称例如&quot;MyTap&quot;)# 在XP SP2或更高版本的系统中，你可能需要有选择地禁用掉针对TAP适配器的防火墙# 通常情况下，非Windows系统则不需要该指令。;dev-node MyTap# CA根证书路径ca /etc/openvpn/server/certs/ca.crt# OpenVPN服务端证书路径cert /etc/openvpn/server/certs/server.crt# OpenVPN服务端密钥路径key /etc/openvpn/server/certs/server.key# Diffie-Hellman算法密钥文件路径dh /etc/openvpn/server/certs/dh.pem# 出于SSL/TLS之外更多的安全考虑，创建一个&quot;HMAC 防火墙&quot;可以帮助抵御DoS攻击和UDP端口淹没攻击。# 你可以使用以下命令来生成：# openvpn --genkey --secret ta.key# 服务器和每个客户端都需要拥有该密钥的一个拷贝。# 第二个参数在服务器端应该为&apos;。# tls-auth key，参数0可以省略，如果不省略，那么客户端配置文件相应的参数tls-auth该配成 1。如果省略，那么客户端不需要 tls-auth 配置tls-auth /etc/openvpn/server/certs/ta.key 0# 选择一个密码加密算法。# 该配置项也必须复制到每个客户端配置文件中。;cipher BF-CBC # Blowfish (默认);cipher AES--CBC # AES;cipher DES-EDE3-CBC # Triple-DES# 该网段为OpenVPN虚拟网卡网段，不要和内网网段冲突即可。OpenVPN默认使用10.8.0.0/24网段为客户端分配IP地址server 10.8.0.0 255.255.255.0# 指定用于记录客户端和虚拟IP地址的关联关系的文件，当重启OpenVPN时，再次连接的客户端将分配到与上一次分配相同的虚拟IP地址ifconfig-pool-persist ipp.txt# 主DNS服务器配置，可以根据需要指定其他DNSpush &quot;dhcp-option DNS 8.8.8.8&quot;# 备DNS服务器配置，可以根据需要指定其他DNSpush &quot;dhcp-option DNS 8.8.4.4&quot;# 推送路由信息到客户端，告诉客户端连接172.18.0.0/16这个网段的流量通过openvpn转发，以允许客户端能够连接到服务端背后的其他私有子网;# 其中172.18.0.0/16网段是你要连接的openvpn服务端的私网ip地址段，类似于局部代理;# 使客户端机器在浏览器访问其他正常网页时由本地网卡出去，从而达到不影响本地网络的网速。push &quot;route 172.18.0.0 255.255.0.0&quot;# 客户端所有流量都通过open VPN虚拟网卡转发，类似于全局代理，这样客户端在浏览器访问其他正常网站时;# 也是通过OpenVPN虚拟网卡出去访问，会严重影响客户端访问正常网页的网速;push &quot;redirect-gateway def1&quot;# 该指令仅针对以太网桥接模式。# 首先，你必须使用操作系统的桥接能力将以太网网卡接口和TAP接口进行桥接。# 然后，你需要手动设置桥接接口的IP地址、子网掩码；# 在这里，我们假设为10.。# 最后，我们必须指定子网的一个IP范围(例如从10.8.0.50开始，到10.8.0.100结束)，以便于分配给连接的客户端。# 如果你不是以太网桥接模式，直接注释掉这行指令即可。;server-bridge 10.8.0.4 255.255.255.0 10.8.0.50 10.8.0.100# 该指令仅针对使用DHCP代理的以太网桥接模式，# 此时客户端将请求服务器端的DHCP服务器，从而获得分配给它的IP地址和DNS服务器地址。# 在此之前，你也需要先将以太网网卡接口和TAP接口进行桥接。# 注意：该指令仅用于OpenVPN客户端，并且该客户端的TAP适配器需要绑定到一个DHCP客户端上。;server-bridge# 允许一个用户多个终端连接# 如果多个客户端可能使用相同的证书/私钥文件或Common Name进行连接，那么你可以取消该指令的注释。# 建议该指令仅用于测试目的。对于生产使用环境而言，每个客户端都应该拥有自己的证书和私钥。# 如果你没有为每个客户端分别生成Common Name唯一的证书/私钥，你可以取消该行的注释(但不推荐这样做)。;duplicate-cn# keepalive指令将导致类似于ping命令的消息被来回发送，以便于服务器端和客户端知道对方何时被关闭。# 每10秒钟ping一次，如果120秒内都没有收到对方的回复，则表示远程连接已经关闭。keepalive 10 120# 在VPN连接上启用压缩。# 如果你在此处启用了该指令，那么也应该在每个客户端配置文件中启用它。comp-lzo# 允许并发连接的客户端的最大数量;max-clients# 去掉该指令的注释将允许不同的客户端之间相互&quot;可见&quot;(允许客户端之间互相访问)。# 该选项允许连接openvpn的客户端直接通讯而不经过openvpn服务端网关。# 默认情况下，客户端只能&quot;看见&quot;服务器。为了确保客户端只能看见服务器，你还可以在服务器端的TUN/TAP接口上设置适当的防火墙规则。client-to-client# 持久化选项可以尽量避免访问那些在重启之后由于用户权限降低而无法访问的某些资源。persist-keypersist-tun# OpenVPN进程启动用户，OpenVPN用户在安装完openvpn安装包后就自动生成了# 在完成初始化工作之后，降低OpenVPN守护进程的权限是个不错的主意。# 该指令仅限于非Windows系统中使用。user openvpngroup openvpn# 默认情况下，日志消息将写入syslog(在Windows系统中，如果以服务方式运行，日志消息将写入OpenVPN安装目录的log文件夹中)。# 你可以使用log或者log-append来改变这种默认情况。# &quot;log&quot;方式在每次启动时都会清空之前的日志文件。# &quot;log-append&quot;这是在之前的日志内容后进行追加。# 你可以使用两种方式之一(但不要同时使用)。;log /var/log/openvpn/openvpn.loglog-append /var/log/openvpn/openvpn.log# 输出一个简短的状态文件，用于显示当前的连接状态，该文件每分钟都会清空并重写一次。status /var/log/openvpn/openvpn-status.log# 为日志文件设置适当的冗余级别(~)。冗余级别越高，输出的信息越详细。# 0 表示静默运行，只记录致命错误。# 4 表示合理的常规用法。# 5 可以帮助调试连接错误。# 9 表示极度冗余，输出非常详细的日志信息。verb 3# 重复信息的沉默度。# 相同类别的信息只有前20条会输出到日志文件中。;mute# 当服务端重新启动时，通知客户端可以自动重新连接。# 当proto使用tcp时，需要注销该行配置，否则会导致服务端无法启动explicit-exit-notify 1# 为指定的客户端分配指定的IP地址，或者客户端背后也有一个私有子网想要访问VPN，# 那么你可以针对该客户端的配置文件使用ccd子目录。# (简而言之，就是允许客户端所在的局域网成员也能够访问VPN) # 举个例子：假设有个Common Name为/255.255.255.248。# 首先，你需要去掉下面两行指令的注释：;client-config-dir ccd;route 192.168.40.128 255.255.255.248# 然后创建一个文件ccd/Thelonious，该文件的内容为：# iroute 192.168.40.128 255.255.255.248# 这样客户端所在的局域网就可以访问VPN了。# 注意，这个指令只能在你是基于路由、而不是基于桥接的模式下才能生效。# 比如，你使用了&quot;dev tun&quot;和&quot;server&quot;指令。# 再举个例子：假设你想给Thelonious分配一个固定的IP地址10.。# 首先，你需要去掉下面两行指令的注释：;client-config-dir ccd;route 10.9.0.0 255.255.255.252# 然后在文件ccd/Thelonious中添加如下指令：# ifconfig-push 10.9.0.1 10.9.0.2## 如果你想要为不同群组的客户端启用不同的防火墙访问策略，你可以使用如下两种方法：# 运行多个OpenVPN守护进程，每个进程对应一个群组，并为每个进程(群组)启用适当的防火墙规则。# (进阶)创建一个脚本来动态地修改响应于来自不同客户的防火墙规则。# 关于learn-address脚本的更多信息请参考官方手册页面。;learn-address ./script 4.防火墙相关配置（使用 iptables 添加 snat 规则） 4.1 禁用 Centos7 默认的 firewalld，使用经典的 iptables 防火墙管理软件：12# systemctl stop firewalld # 停用系统默认的firewalld防火墙# systemctl mask firewalld # 注销firewalld防火墙服务 4.2 禁用 SELinux12# setenforce 0 # 马上关闭，立即生效# sed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/g&apos; /etc/selinux/config # 需要重启服务器生效 4.3 启用iptables123# systemctl enable iptables # 开机自启动# systemctl start iptables # 立即启动# iptables -F # 清理防火墙默认filter表规则，使用-t选项指定表，默认filter表，还有nat,mangle表 4.4 添加防火墙规则，将 openvpn 的网络流量转发到公网：snat 规则12# iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE# iptables-save &gt; /etc/sysconfig/iptables # iptables 规则持久化保存 4.5 Linux 服务器启用内核地址转发12# echo &apos;net.ipv4.ip_forward = 1&apos; &gt;&gt; /etc/sysctl.conf# sysctl -p # 使配置立即生效，这一步一定要执行，否则配置未生效。 5.启动 open VPN123# systemctl start openvpn@server # 启动# systemctl enable openvpn@server # 开机自启动# systemctl status openvpn@server # 查看服务状态至此，OpenVPN服务端搭建完成。 OpenVPN客户端部署OpenVPN 服务端搭建完了，但是我们该如何使用呢？下面以 Windows 平台下使用为例： 安装客户端软件要连接到 open VPN 服务端首先得需要一个客户端软件，在 Windows 下推荐使用 OpenVPN GUI，下载地址： https://openvpn.net/community-downloads/ 。OpenVPN GUI 是一个开源、免费的 Windows 版 OpenVPN 客户端软件，下载安装好OpenVPN GUI 软件。 创建一个OpenVPN用户创建一个OpenVPN用户的方法有两种，一种是客户端使用证书密钥的认证方式连接OpenVPN服务端，一种是客户端使用用户密码的认证方式连接OpenVPN服务端，这里以客户端使用证书密钥登录的认证方式为例，关于用户密码认证方式可以查看我的博客中的 OpenVPN使用账号密码认证方式登陆 这篇博文。 创建客户端证书以及相关配置文件接下来在服务端创建一个 OpenVPN 用户：其实创建用户的过程就是生成客户端 SSL 证书的过程，然后将其他相关的证书文件、key、.ovpn文件（客户端配置文件）打包到一起供客户端使用。由于创建一个用户的过程比较繁琐，所以在此将整个过程写成了一个脚本 ovpn_user.sh，脚本内容比较简单，一看就懂：首先创建一个客户端配置模板文件 sample.ovpn，该文件在创建OpenVPN用户的脚本中会用到，放到 /etc/openvpn/client/ 目录下，执行以下命令：12# cd /etc/openvpn/client/# vim sample.ovpnsample.ovpn文件内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192################################################################# 针对多个客户端的OpenVPN 2.0 的客户端配置文件示例## 该配置文件可以被多个客户端使用，当然每个客户端都应该有自己的证书和密钥文件## 在Windows上此配置文件的后缀应该是&quot;.ovpn&quot;，在Linux/BSD系统中则是&quot;.conf&quot;################################################################# 指定这是一个客户端，将从服务器上获取某些配置文件指令client# 指定连接的服务器是采用TCP还是UDP协议。# 这里需要使用与服务器端相同的设置。;proto tcpproto udp# 指定OpenVPN创建的通信隧道类型。# &quot;dev tun&quot;将会创建一个路由IP隧道，# &quot;dev tap&quot;将会创建一个以太网隧道。# 如果你是以太网桥接模式，并且提前创建了一个名为&quot;tap0&quot;的与以太网接口进行桥接的虚拟接口，则你可以使用&quot;dev tap0&quot;# 如果你想控制VPN的访问策略，你必须为TUN/TAP接口创建防火墙规则。# 在非Windows系统中，你可以给出明确的单位编号(unit number)，例如&quot;tun0&quot;。# 在Windows中，你也可以使用&quot;dev-node&quot;。# 在多数系统中，除非你部分禁用或者完全禁用了TUN/TAP接口的防火墙，否则VPN将不起作用;dev tapdev tun# 指定服务端的主机名或者IP以及端口# 如果有多个VPN服务器，为了实现负载均衡，可以设置多个remote指令remote [OpenVPN服务端公网 ip，根据实际情况填写] 1194# 如果开启多个remote指令，启动该指令将随机连接其中的一台服务器# 否则，客户端将按照指定的先后顺序依次尝试连接;remote-random # 启用该指令，与服务器连接中断后将自动重新连接，这在网络不稳定的情况下(例如：笔记本电脑无线网络)非常有用。resolv-retry infinite # 大多数客户端不需要绑定本机特定的端口号nobind # 在初始化完毕后，降低OpenVPN的权限(该指令仅限于非Windows系统中使用);user openvpn;group openvpn# SSL/TLS 参数配置。# 更多描述信息请参考服务器端配置文件。# 最好为每个客户端单独分配.crt/.key文件对。# 单个CA证书可以供所有客户端使用。ca ca.crtcert admin.crtkey admin.key# 指定采用服务器校验方式remote-cert-tls server# 如果服务器端使用了tls-auth密钥，那么每个客户端也都应该有该密钥。tls-auth ta.key 1# 指定密码的加密算法。# 如果服务器端启用了cipher指令选项，那么你必须也在这里指定它;cipher AES--CBC# 持久化选项可以尽量避免访问在重启时由于用户权限降低而无法访问的某些资源persist-tunpersist-key# 如果你是通过HTTP代理方式来连接到实际的VPN服务器，请在此处指定代理服务器的主机名(或IP)和端口号。# 如果你的代理服务器需要身份认证，请参考官方手册页面;http-proxy-retry # 如果失败将重试;http-proxy [proxy server] [proxy port #]# 无线网络通常会产生大量的重复数据包。设置此标识将忽略掉重复数据包的警告信息mute-replay-warnings# 在VPN连接中启用压缩。# 该指令的启用/禁用应该与服务器端保持一致。comp-lzo# 设置日志文件冗余级别(~)。# 表示静默运行，只记录致命错误。# 表示合理的常规用法。# 和 可以帮助调试连接错误。# 表示极度冗余，输出非常详细的日志信息verb 3# 忽略过多的重复信息。# 相同类别的信息只有前20条会输出到日志文件中。;mute # 该参数能防止密码被缓存到内存中auth-nocache下面编写创建 OpenVPN 用户的脚本add_vpn_user.sh，执行以下命令：12# cd /etc/openvpn/client# vim add_vpn_user.shadd_vpn_user.sh脚本内容如下:123456789101112131415161718192021222324252627282930#!/bin/bashset -eOVPN_USER_KEYS_DIR=/etc/openvpn/client/keysEASY_RSA_VERSION=3EASY_RSA_DIR=/etc/openvpn/easy-rsa/PKI_DIR=$EASY_RSA_DIR/$EASY_RSA_VERSION/pkifor user in &quot;$@&quot;do if [ -d &quot;$OVPN_USER_KEYS_DIR/$user&quot; ]; then rm -rf $OVPN_USER_KEYS_DIR/$user rm -rf $PKI_DIR/reqs/$user.req sed -i &apos;/&apos;&quot;$user&quot;&apos;/d&apos; $PKI_DIR/index.txt fi cd $EASY_RSA_DIR/$EASY_RSA_VERSION # 生成客户端 ssl 证书文件 ./easyrsa build-client-full $user nopass # 整理下生成的文件 mkdir -p $OVPN_USER_KEYS_DIR/$user cp $PKI_DIR/ca.crt $OVPN_USER_KEYS_DIR/$user/ # CA 根证书 cp $PKI_DIR/issued/$user.crt $OVPN_USER_KEYS_DIR/$user/ # 客户端证书 cp $PKI_DIR/private/$user.key $OVPN_USER_KEYS_DIR/$user/ # 客户端证书密钥 cp /etc/openvpn/client/sample.ovpn $OVPN_USER_KEYS_DIR/$user/$user.ovpn # 客户端配置文件 sed -i &apos;s/admin/&apos;&quot;$user&quot;&apos;/g&apos; $OVPN_USER_KEYS_DIR/$user/$user.ovpn cp /etc/openvpn/server/certs/ta.key $OVPN_USER_KEYS_DIR/$user/ta.key # auth-tls 文件 cd $OVPN_USER_KEYS_DIR zip -r $user.zip $userdoneexit 0注：执行上面的脚本创建一个OpenVPN用户，脚本用法如下：12&gt; # sh add_vpn_user.sh &lt;username&gt;&gt;其中 username 可以随意命名执行完创建用户的脚本后会在 /etc/openvpn/client/keys 目录下生成以命名的 zip 打包文件，将该压缩包下载到本地解压，然后将里面的客户端证书和key以及.ovpn 文件拖拽到 OpenVPN GUI 客户端软件安装路径下的config目录下即可使用。zip压缩包里面的文件如下，示例：123456.├── ca.crt├── username.crt├── username.key├── username.ovpn└── ta.key至此，OpenVPN客户端安装配置完成，测试连接OpenVPN服务端，见如下图所示，表示连接成功并可以服务端通信了。 删除一个 OpenVPN 用户上面我们知道了如何添加一个用户，那么如果公司员工离职了或者其他原因，想删除对应用户 OpenVPN 的使用权，该如何操作呢？其实很简单，OpenVPN 的客户端和服务端的认证主要通过 SSL 证书进行双向认证，所以只要吊销对应用户的 SSL 证书，分别执行以下3个步骤即可。吊销用户证书，假设要吊销的用户名为 username123# cd /etc/openvpn/easy-rsa/3/# ./easyrsa revoke username# ./easyrsa gen-crl编辑 OpenVPN 服务端配置文件 server.conf 添加如下配置:1# crl-verify /etc/openvpn/easy-rsa/3/pki/crl.pem重启 OpenVPN 服务端使其生效1# systemctl start openvpn@server为了方便，也将上面步骤整理成了一个脚本，执行以下命令，创建一键删除OpenVPN用户的脚del_vpn_user.sh：12# cd /etc/openvpn/client# vim add_vpn_user.shdel_vpn_user.sh脚本内容如下:12345678910111213141516171819#!/bin/bashset -eOVPN_USER_KEYS_DIR=/etc/openvpn/client/keysEASY_RSA_VERSION=3EASY_RSA_DIR=/etc/openvpn/easy-rsa/for user in &quot;$@&quot;do cd $EASY_RSA_DIR/$EASY_RSA_VERSION echo -e &apos;yes\\n&apos; | ./easyrsa revoke $user ./easyrsa gen-crl # 吊销掉证书后清理客户端相关文件 if [ -d &quot;$OVPN_USER_KEYS_DIR/$user&quot; ]; then rm -rf $OVPN_USER_KEYS_DIR/$&#123;user&#125;* fi systemctl restart openvpn@serverdoneexit 0注：执行上面的脚本创建一个OpenVPN用户，脚本用法如下：12&gt; # sh del_vpn_user.sh &lt;username&gt;&gt;其中 username 是你要删除的OpenVPN用户名 安装过程中遇到的问题及解决方法 问题 1：搭建好OpenVPN，配置好server.conf文件和iptables防火墙后，使用systemctl无法启动openvpn 服务端。 问题原因及解决方法：可以查看/var/log/openvpn/openvpn.log日志文件，查看报错；或者执行 journalctl -u openvpn@server 看看log报什么错。 博主出现服务端无法启动的原因是服务端配置文件的注释内容格式(中文字符一行太长)有问题导致无法启动服务端，只要将注释分成多行即可。 问题 2：open VPN 客户端可以正常连接到服务端，但是无法上网，ping 任何地址都不通，只有服务端公网 ip 可以 ping 通。 问题原因及解决方法：主要原因是服务的地址转发功能没打开，其实我前面配置了 echo net.ipv4.ip_forward = 1 &gt;&gt; /etc/sysctl.conf，但是没有执行 sysctl -p 使其立即生效，所以才导致出现问题。因此一定要记得两条命令都要执行。 问题 3:open VPN 可以正常使用，但是看客户端日志却有如下错误：122019-06-15 02:39:03.957926 AEAD Decrypt error: bad packet ID (may be a replay): [ #6361 ] -- see the man page entry for --no-replay and --replay-window for more info or silence this warning with --mute-replay-warnings2019-06-15 02:39:23.413750 AEAD Decrypt error: bad packet ID (may be a replay): [ #6508 ] -- see the man page entry for --no-replay and --replay-window for more info or silence this warning with --mute-replay-warnings 问题原因及解决方法：其实这个问题一般在 open VPN 是 UDP 服务的情况下出现，主要原因是 UDP 数据包重复发送导致，在 Wi-Fi 网络下经常出现，这并不影响使用，但是我们可以选择禁止掉该错误：根据错误提示可知使用 –mute-replay-warnings 参数可以消除该警告，我们使用的 open VPN 是 GUI 的，所以修改客户端 .ovpn 配置文件，末尾添加：mute-replay-warnings 即可解决。该问题在这里有讨论：https://sourceforge.net/p/openvpn/mailman/message/10655695/ 相关文档关于 open VPN 客户端和服务端配置文件配置项说明：很全面，可以随时查看不懂的配置项https://community.openvpn.net/openvpn/wiki/Openvpn24ManPagehttps://openvpn.net/ | OpenVPN 官网https://www.bbsmax.com/A/D854pyPw5E/https://www.fandenggui.com/post/centos7-install-openvpn.html | Centos7 安装 OpenVPNhttps://www.howtoing.com/how-to-install-openvpn-on-centos-7 | Centos7 安装 OpenVPNhttps://www.xiaohui.com/dev/server/20070904-revoke-openvpn-client.htm | 吊销客户端证书https://scott.stevensononthe.net/2015/02/how-to-addremove-additional-users-to-openvpn/ | 吊销客户端证书https://tunnelblick.net/cConnectedBut.html | open VPN 一些常见问题https://tunnelblick.net/ipinfo | 本地公网 ip 查看","categories":[{"name":"CentOS","slug":"CentOS","permalink":"https://linuxops.fun/categories/CentOS/"}],"tags":[{"name":"OpenVPN","slug":"OpenVPN","permalink":"https://linuxops.fun/tags/OpenVPN/"}]},{"title":"ShadowsocksR使用进阶","slug":"ShadowsocksR使用进阶","date":"2016-06-12T14:19:12.000Z","updated":"2019-12-16T01:41:03.568Z","comments":true,"path":"2016/06/12/1b6ecda8.html","link":"","permalink":"https://linuxops.fun/2016/06/12/1b6ecda8.html","excerpt":"","text":"ShadowsocksR服务端常用命令1234# /etc/init.d/shadowsocks start # 启动shadowsocksR服务# /etc/init.d/shadowsocks stop # 停止shadowsocksR服务# /etc/init.d/shadowsocks restart # 重启shadowsocksR服务# /etc/init.d/shadowsocks status # 查看shadowsocksR服务 ShadowsocksR服务端修改密码、配置多端口教程(1）远程连接服务器，编辑ShadowsocksR服务的配置文件，输入vim /etc/shadowsocks.json(2）按“i”进入编辑模式，编辑如下12345678910111213141516171819202122232425 &#123; \"server\": \"0.0.0.0\", \"server_ipv6\": \"::\", \"local_address\": \"127.0.0.1\", \"local_port\": 1081, \"port_password\":&#123; \"端口1\":\"密码1\", \"端口2\":\"密码2\", \"端口3\":\"密码3\", \"端口4\":\"密码4\" &#125;, \"timeout\": 120, \"udp_timeout\": 60, \"method\": \"chacha20\", \"protocol\": \"auth_sha1_compatible\", \"protocol_param\": \"\", \"obfs\": \"http_simple_compatible\", \"obfs_param\": \"\", \"dns_ipv6\": false, \"connect_verbose_info\": 0, \"redirect\": \"\", \"fast_open\": false, \"workers\": 1&#125;(3）按esc返回，输入:wq回车保存(4）输入以下命令重启ShadowsocksR服务，使配置生效1/etc/init.d/shadowsocks restart # 重启ShadowsocksR服务","categories":[{"name":"Proxy","slug":"Proxy","permalink":"https://linuxops.fun/categories/Proxy/"}],"tags":[]},{"title":"搭建ShadowsocksR实现科学上网","slug":"搭建ShadowsocksR实现科学上网","date":"2016-06-11T11:19:12.000Z","updated":"2019-12-16T01:41:04.657Z","comments":true,"path":"2016/06/11/af735ad7.html","link":"","permalink":"https://linuxops.fun/2016/06/11/af735ad7.html","excerpt":"","text":"创建服务器 注册公有云账号注册公有云账号，这里使用阿里云为例，你们可以自行百度解决，有问题可以在博文评论中提问。 购买境外ECS服务器这里使用阿里云香港ECS实例为例，登录到阿里云控制台，找到云服务器 ECS ，然后点击 创建实例 按钮，地域选择中国香港，实例类型按照自己的预算购买，这里选择最便宜的实例类型 ecs.t5-lc1m1.small；镜像使用Centos7 64位，必须是64位的，可以是其他的系统镜像，但必须是64位的；带宽按照自己的预算购买，这里选择1M带宽；如下图所示： 搭建ShadowsocksR服务 安装配置SSR服务创建好阿里云实例，在阿里云控制台获取实例的公网地址，使用远程工具secureCRT连接服务器，开始搭建hadowsocksR服务（简称SSR服务）。执行以下命令，下载安装SSR服务的脚本，赋予脚本执行权限，然后运行脚本，开始安装SSR服务。123# wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh# chmod +x shadowsocksR.sh# ./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log注：如果这里的shadowsocksR.sh脚本wget链接地址https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh失效，可以使用博文尾部的附件链接地址替代运行后，会提示你设置密码（password）和端口（port），加密方式，协议，混淆。(1) 提示Please enter password for ShadowsocksR:设置SSR连接密码：自己设定（如不设定，默认为 teddysun.com）(2) 提示Please enter a port for ShadowsocksR [1-65535]设置你的服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成）(3) 提示Please select stream cipher for ShadowsocksR:设置加密方式,输入序号回车选择：自己设定(建议chacha20)（如不设定，Python 和 libev 版默认为 aes-256-gcm，R 和 Go 版默认为 aes-256-cfb）(4) 提示Please select protocol for ShadowsocksR:输入序号回车选择协议（protocol）：自己设定（如不设定，默认为 origin）(5) 提示 Please select obfs for ShadowsocksR:输入序号回车选择混淆方式obfs,(免流请选择2:http_simple)（如不设定，默认为 plain）（仅限 ShadowsocksR 版）(6) 设置好以上内容后，看到如下图所示提示，按任意键开始安装SSR服务，按Ctrl + c 返回终止运行脚本，此时我们继续按回车键运行脚本安装SSR服务(7) 脚本开始自己运行，大概几分钟后运行结束，这时会出现红色字体的配置信息，该配置信息就是你前面设置的SSR服务连接的配置内容，请务必牢记，最好截图保存，以免遗忘备注：脚本默认创建单用户配置文件，如需配置多用户，请手动修改相应的配置文件后重启即可。本脚本安装完成后SSR服务即已实现后台启动，且开机自动启动。 停止防火墙允许SSR服务通信停止防火墙请执行以下命令[回车]：1systemctl stop firewalld查看防火墙状态请执行以下命令[回车] ：返回 not running 表示已关闭:1systemctl status firewalld 配置阿里云实例安全组登录阿里云控制台，进入云服务器 ECS，找到你创建的实例，设置实例的安全组，配置安全组允许你前面配置的SSR服务端口通信，如下图所示，可以参考阿里云官方文档配置实例安全组，有问题可以在博文评论区评论。至此，SSR服务端搭建完成，ShadowsocksR客户端可以通过配置SSR服务端代理进行访问国外网站了。 SSR服务端常用命令**卸载方法：**使用 root 用户登录，运行以下命令：1# ./shadowsocksR.sh uninstall**查看进程是否启动：**运行：1# /etc/init.d/shadowsocks status其他命令：启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status配置文件路径：/etc/shadowsocks.json日志文件路径：/var/log/shadowsocks.log代码安装目录：/usr/local/shadowsocks ShadowsocksR客户端科学上网下面以Windows平台为例安装ShadowsocksR客户端，并配置SSR服务端代理信息进行科学上网。 下载安装ShadowsocksR客户端下载好ShadowsocksR-win-4.9.2.zip安装包，将安装包解压到指定的路径下，双击打开ShadowsocksR-dotnet4.0.exe程序，如下图所示，然后添加SSR服务器的服务端配置信息，添加完成后确定保存。下面开始测试上网，打开google浏览器，输入以下网址测试：www.youtube.com返回如上图所示界面，可以正常打开网址，表示已经实现科学上网。 各平台ShadowsocksR客户端地址Windows：https://github.com/shadowsocksrr/shadowsocksr-csharp/releasesMacOS：https://github.com/wzdnzd/ShadowsocksX-NG-R/releasesLinux内核：Debian、Ubantu、CentOS等电脑桌面发行版（不能完全通用，可以尝试一下）https://github.com/shadowsocksrr/electron-ssr/releasesAndroid：https://github.com/shadowsocksrr/shadowsocksr-android/releasesIOS：需要国外账号，推荐shadowrocket（小火箭），potatso（土豆丝） 附件：shadowsocksR安装脚本下载地址：https://raw.githubusercontent.com/Eddieeo/software-package/master/shadowsocksR.shWindows ShadowsocksR客户端下载地址：https://github.com/Eddieeo/software-package/raw/master/ShadowsocksR-win-4.9.2.zip","categories":[{"name":"Proxy","slug":"Proxy","permalink":"https://linuxops.fun/categories/Proxy/"}],"tags":[]},{"title":"多台电脑维护Hexo博客","slug":"多台电脑维护Hexo博客","date":"2015-09-09T14:30:15.000Z","updated":"2019-12-16T01:41:04.660Z","comments":true,"path":"2015/09/09/be6d83ca.html","link":"","permalink":"https://linuxops.fun/2015/09/09/be6d83ca.html","excerpt":"","text":"写博客，不一定是在同一部电脑上写，有可能需要在不同的电脑上进行写博客，所以当有多台电脑进行维护博客源码时，就需要用到远程仓库了，以下分别用远程仓库的两种方法实现Hexo博客源码的备份和维护。 环境准备1234567891011121314151617181920212223242526System Environment:System version: CentOS Linux release 7.6.1810 (Core) Git version: 1.8.3.1Nvm version: 0.34.0Nodejs version: v12.10.0Npm version: 6.10.3Hexo version: hexo: 3.9.0 hexo-cli: 2.0.0 os: Linux 3.10.0-957.el7.x86_64 linux x64 node: 12.10.0 v8: 7.6.303.29-node.16 uv: 1.31.0 zlib: 1.2.11 brotli: 1.0.7 ares: 1.15.0 modules: 72 nghttp2: 1.39.2 napi: 4 llhttp: 1.1.4 http_parser: 2.8.0 openssl: 1.1.1c cldr: 35.1 icu: 64.2 tz: 2019a unicode: 12.1 安装Git, node 和 hexo 安装 git:1$ sudo yum install -y git 安装 nodejs:安装 Node.js 的最佳方式是使用 nvm。nvm 的开发者提供了一个自动安装 nvm 的简单脚本。curl:1$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | shwget:1$ wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | sh安装nvm完成后，重新登录终端(退出重新登录命令行终端)并执行下列命令即可安装 Node.js。1$ nvm install node 安装 Hexo:1$ npm install -g hexo-cli 多人维护Hexo博客源代码当有多人维护Hexo博客源码时，就需要使用远程仓库进行维护管理博客源码了，以下分别介绍两种多人维护Hexo博客源码的方式。 方法一：新建远程代码仓库备份Hexo博客源码在Coding或者Github上新建一个仓库，专门用于存放Hexo博客站点的源码，新建仓库可参考前面的 Hexo搭建个人博客系统 这篇博文。 备份Hexo博客源代码到新建的远程仓库master在Hexo站点目录blog下执行以下命令，完成本地Hexo博客源码同步到远程仓库。12345# git init # 初始化本地项目加入git管理# git remote add origin &lt;远程仓库地址&gt; # 使用git关联本地项目和远端仓库 # git add -A # 将所有文件添加给git暂存区，包括删除的文件# git commit -m &quot;备注信息&quot; # 将git缓存区的所有文件提交到本地git仓库# git push origin master # 推送本地git仓库到远程仓库主分支master此时，已完成Hexo博客源代码的备份，其他人可以通过拉取博客源码进行维护了。 在另一台电脑编写Hexo博文备份操作首先使用 ssh 或 https 链接地址下载博客源码。12345ssh: # git clone git@e.coding.net:xxx/xxx.git &lt;本地文件夹名&gt; https: # git clone https://e.coding.net/xxx/xxx.git &lt;本地文件夹名&gt;cd切换到Hexo站点目录下，安装Hexo依赖插件模块。123# cd blogcode# npm install # 通过当前目录下的package.json文件安装依赖包# npm install hexo-deployer-git # 安装git部署插件然后执行以下指令，前台启动Hexo服务预览博客。如果想要pm2管理Hexo后台开机自启动，可以参考前面的 Hexo搭建个人博客系统 这篇博文。1# hexo s # 前台启动Hexo服务预览博客完成以上操作后，就可以继续编写博客了，可以使用 hexo new &lt;title&gt; 指令编写Markdown文档；也可以使用Markdown文档编辑器编写文档，然后将编写好的Markdown文档上传到Hexo站点目录的 source/_post 目录下，重启Hexo服务，在浏览器输入以下地址进行预览：http://IPADDRESS:4000，博客又完整回来了。注：IPADDRESS，请使用ifconfig命令在服务器上查看每次编写好博文发布到Coding或者Github Pages之后，都要进行Hexo博客源码的备份，继续执行以下命令1234# git status # 查看本地git仓库工作目录和暂存区的状态# git add -A # 将所有文件添加给git暂存区，包括删除的文件# git commit -m &quot;备注信息&quot; # 将git缓存区的所有文件提交到本地git仓库# git push origin master # 推送本地git仓库到远程仓库主分支master后面继续写博文的时候，需要先执行以下命令，拉取远程仓库的Hexo博客源码合并，然后才可以继续编写博文。1# git pull origin master[:master] # 拉取远程origin主机的master分支，与本地的master分支合并，中括号部分可以省略不写 方法二：使用发布静态页的远程仓库新分支备份Hexo博客源码在部署好的Hexo站点目录下的 _config.yml 中，修改网站deploy的配置内容为如下所示：1234deploy: type: git repository: git@git.coding.net:xxx/xxx.git branch: master 生成静态页并部署到远程Coding或者Github Pages仓库修改好所有博客设置，文章写好之后，使用以下命令生成静态页面并发布到远程仓库。注意：如果是发布到Coding需要开启 coding的持续部署静态网站功能 ，稍等片刻就能看到生成的博客访问地址了。12# hexo g # 生成静态页# hexo d # 发布到远程仓库 备份Hexo博客源代码到远程静态页仓库的Coding-pages分支在Hexo站点目录blog下执行以下操作：123456# git init # 初始化本地项目加入git管理# git remote add origin &lt;远程仓库地址&gt; # 使用git关联本地项目和远端仓库 # git checkout -b coding-pages # 创建并切换到分支coding-pages# git add -A # 将所有文件添加给git暂存区，包括删除的文件# git commit -m &quot;提交&quot; # 将git缓存区的所有文件提交到本地git仓库# git push origin coding-pages # 推送本地git仓库到远程仓库分支coding-pages此时，已成功备份到静态页远程仓库的 coding-pages 分支 在另一台电脑编写Hexo博文备份操作首先使用 ssh 或 https 链接地址下载博客源码。1# git clone &lt;静态页远程仓库地址&gt; &lt;本地文件夹名&gt;克隆远程仓库后，当前默认为远程仓库的 master 分支，也就是 hexo g 编译后发布到远程仓库的静态页文件。执行以下命令切换到静态页远程仓库的 coding-pages 分支。12# git branch -a # 查看本地和远程分支# git checkout coding-pages # 切换到coding-pasges分支cd切换到Hexo站点目录下，安装Hexo依赖插件模块，输入以下命令：1234# npm install -g hexo-cli # 安装hexo# npm install # 安装依赖包# npm install hexo-deployer-git # 安装git部署插件（记得，不需要hexo init这条指令）然后执行以下指令，前台启动Hexo服务预览博客。如果想要pm2管理Hexo后台开机自启动，可以参考前面的 Hexo搭建个人博客系统 这篇博文。1# hexo s # 前台启动Hexo服务预览博客在浏览器中输入网址：http://IPADDRESS:4000，博客又完整回来了。注：IPADDRESS，请使用ifconfig命令在服务器上查看每次编写好博文发布到Coding或者Github Pages之后，都要进行Hexo博客源码的备份，执行以下命令完成备份：1234# git checkout coding-pages # 切换到分支coding-pages# git add -A # 将所有文件添加给git暂存区，包括删除的文件# git commit -m &quot;提交&quot; # 将git缓存区的所有文件提交到本地git仓库# git push origin coding-pages # 推送本地git仓库到远程仓库分支coding-pages后面继续写博文的时候，需要先执行以下命令，拉取静态页远程仓库coding-pages分支的Hexo博客源码合并，然后才可以继续编写博文。1# git pull origin coding-pages[:master] # 拉取远程origin主机的coding-pages分支，与本地的master分支合并，中括号部分可以省略不写","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://linuxops.fun/categories/Hexo/"}],"tags":[]},{"title":"Hexo常见错误总结","slug":"Hexo常见错误总结","date":"2015-09-08T12:16:12.000Z","updated":"2019-12-16T01:41:03.570Z","comments":true,"path":"2015/09/08/77ceaa9d.html","link":"","permalink":"https://linuxops.fun/2015/09/08/77ceaa9d.html","excerpt":"","text":"本人在搭建Hexo博客的过程中，遇到了一些问题，通过百度，google等手段，加上自己的理解，进行了问题的复现和解决，现在总结成以下几点，希望可以帮助到一些人。 Hexo使用常见错误一： 问题描述：Template render error: (unknown path)Hexo站点目录下的source/_post目录中如果没有任何Markdown文档时，在使用 hexo s 命令启动Hexo进行前台预览时，会报以下错误：1234567891011121314151617181920212223242526[root@Hexo-Blog-Server blog]# hexo sINFO Start processingINFO Generating Baidu urls for last 100 postsINFO Posts urls generated in baidu_urls.txtFATAL Something&apos;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) [Line 8, Column 25] Error: Unable to call `the return value of (posts[&quot;first&quot;])[&quot;updated&quot;][&quot;toISOString&quot;]`, which is undefined or falsey at Object._prettifyError (/root/blog/node_modules/nunjucks/src/lib.js:36:11) at /root/blog/node_modules/nunjucks/src/environment.js:567:19 at Template.root [as rootRenderFunc] (eval at _compile (/root/blog/node_modules/nunjucks/src/environment.js:637:18), &lt;anonymous&gt;:235:3) at Template.render (/root/blog/node_modules/nunjucks/src/environment.js:556:10) at Hexo.module.exports (/root/blog/node_modules/hexo-generator-feed/lib/generator.js:41:24) at Hexo.tryCatcher (/root/blog/node_modules/bluebird/js/release/util.js:16:23) at Hexo.&lt;anonymous&gt; (/root/blog/node_modules/bluebird/js/release/method.js:15:34) at /root/blog/node_modules/hexo/lib/hexo/index.js:318:20 at tryCatcher (/root/blog/node_modules/bluebird/js/release/util.js:16:23) at MappingPromiseArray._promiseFulfilled (/root/blog/node_modules/bluebird/js/release/map.js:61:38) at MappingPromiseArray.PromiseArray._iterate (/root/blog/node_modules/bluebird/js/release/promise_array.js:114:31) at MappingPromiseArray.init (/root/blog/node_modules/bluebird/js/release/promise_array.js:78:10) at MappingPromiseArray._asyncInit (/root/blog/node_modules/bluebird/js/release/map.js:30:10) at _drainQueueStep (/root/blog/node_modules/bluebird/js/release/async.js:142:12) at _drainQueue (/root/blog/node_modules/bluebird/js/release/async.js:131:9) at Async._drainQueues (/root/blog/node_modules/bluebird/js/release/async.js:147:5) at Immediate.Async.drainQueues [as _onImmediate] (/root/blog/node_modules/bluebird/js/release/async.js:17:14) at processImmediate (internal/timers.js:439:21) 解决方法：查看是否安装了hexo-generator-feed插件，执行以下命令：123[root@Hexo-Blog-Server blog]# npm list hexo-generator-feedhexo-site@0.0.0 /root/blog└── hexo-generator-feed@2.0.0 方法一：Hexo站点目录下的source/_post目录中添加文章Hexo站点目录下的source/_post目录中不能一片文章都没有，可以使用 hexo new &lt;title&gt; 命令创建新文章，也可以使用Markdown编辑器编写好文章之后上传到source/_post目录中，这样再执行 hexo s 命令启动Hexo进行前台预览时，就不会报错了。 方法二：卸载 hexo-generator-feed 插件执行以下命令，卸载Hexo的 hexo-generator-feed 插件注：不建议使用此方法1# npm uninstall hexo-generator-feed卸载完成后，再执行 hexo s 命令启动Hexo进行前台预览时，就不会报错了。 Hexo使用常见错误二： 问题描述：Cannot read property ‘count’ of undefined使用 Hexo server 启动Hexo服务进行预览的时候，报如下所示错误：123456789101112131415161718192021222324252627282930313233343536[root@Hexo-Blog-Server blog]# hexo sINFO Start processingconfig.translate_title==&gt; undefinedconfig.url==&gt; https://linuxops.funconfig.translate_title==&gt; undefinedconfig.url==&gt; https://linuxops.funconfig.translate_title==&gt; undefinedconfig.url==&gt; https://linuxops.funconfig.translate_title==&gt; undefinedconfig.url==&gt; https://linuxops.funconfig.translate_title==&gt; undefinedconfig.url==&gt; https://linuxops.funconfig.translate_title==&gt; undefinedconfig.url==&gt; https://linuxops.funconfig.translate_title==&gt; undefinedconfig.url==&gt; https://linuxops.funconfig.translate_title==&gt; undefinedconfig.url==&gt; https://linuxops.funconfig.translate_title==&gt; undefinedconfig.url==&gt; https://linuxops.funFATAL Something&apos;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlTypeError: Cannot read property &apos;count&apos; of undefined at Hexo.module.exports (/root/blog/node_modules/hexo-baidu-url-submit/lib/generator.js:4:41) at Hexo.tryCatcher (/root/blog/node_modules/bluebird/js/release/util.js:16:23) at Hexo.&lt;anonymous&gt; (/root/blog/node_modules/bluebird/js/release/method.js:15:34) at /root/blog/node_modules/hexo/lib/hexo/index.js:318:20 at tryCatcher (/root/blog/node_modules/bluebird/js/release/util.js:16:23) at MappingPromiseArray._promiseFulfilled (/root/blog/node_modules/bluebird/js/release/map.js:61:38) at MappingPromiseArray.PromiseArray._iterate (/root/blog/node_modules/bluebird/js/release/promise_array.js:114:31) at MappingPromiseArray.init (/root/blog/node_modules/bluebird/js/release/promise_array.js:78:10) at MappingPromiseArray._asyncInit (/root/blog/node_modules/bluebird/js/release/map.js:30:10) at _drainQueueStep (/root/blog/node_modules/bluebird/js/release/async.js:142:12) at _drainQueue (/root/blog/node_modules/bluebird/js/release/async.js:131:9) at Async._drainQueues (/root/blog/node_modules/bluebird/js/release/async.js:147:5) at Immediate.Async.drainQueues [as _onImmediate] (/root/blog/node_modules/bluebird/js/release/async.js:17:14) at processImmediate (internal/timers.js:439:21) 解决方法：查看是否安装了hexo-baidu-url-submit插件，执行以下命令：123[root@Hexo-Blog-Server blog]# npm list hexo-baidu-url-submit hexo-site@0.0.0 /root/blog└── hexo-baidu-url-submit@0.0.6如上所示，显示Hexo站点中安装了hexo-baidu-url-submit插件，可通过一下两种方法解决这个问题。 方法一：卸载hexo-baidu-url-submit依赖包1# npm uninstall hexo-baidu-url-submit --save然后再执行 Hexo server 启动Hexo服务进行预览，就不回去报错了。 方法二：在Hexo站点配置文件_config.yml中增加以下配置123456# baidu site Collectionbaidu_url_submit: count: 100 # 提交最新的一个链接 host: # 填写博客域名，在百度站长平台中注册的域名 token: # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里然后再执行 Hexo server 启动Hexo服务进行预览，就不回去报错了。 Hexo使用常见错误三： 问题描述：ERROR Deployer not found: git使用 hexo d 命令将Hexo站点下 .deploy_git 目录下的静态页面发布到远程仓库时，报如下所示错误：12[root@Hexo-Blog-Server blog]# hexo d ERROR Deployer not found: git 解决方法：使用git进行发布时，需要安装0 hexo-deployer-git 插件。执行以下命令进行安装。1# npm install hexo-deployer-git --save安装完成后，在Hexo的站点配置文件_config.yml中增加以下配置123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@***.github.com:***/***.github.io.git branch: master注：Hexo 3.0 以上部署类型不再是github，而是 git 。 Hexo使用常见错误四： 问题描述：Unhandled rejection TypeError: Cannot set property ‘lastIndex’ of undefined使用 hexo d 发布静态页时，报如下所示错误：1234567891011121314151617181920212223Unhandled rejection TypeError: Cannot set property &apos;lastIndex&apos; of undefined at highlight (/Users/leesin/Desktop/blog/node_modules/highlight.js/lib/highlight.js:511:35) at /Users/leesin/Desktop/blog/node_modules/highlight.js/lib/highlight.js:561:21 at Array.forEach (&lt;anonymous&gt;) at Object.highlightAuto (/Users/leesin/Desktop/blog/node_modules/highlight.js/lib/highlight.js:560:40) at /Users/leesin/Desktop/blog/node_modules/hexo-util/lib/highlight.js:117:25 at highlight (/Users/leesin/Desktop/blog/node_modules/hexo-util/lib/highlight.js:120:7) at highlightUtil (/Users/leesin/Desktop/blog/node_modules/hexo-util/lib/highlight.js:22:14) at /Users/leesin/Desktop/blog/node_modules/hexo/lib/plugins/filter/before_post_render/backtick_code_block.js:62:15 at String.replace (&lt;anonymous&gt;) at Hexo.backtickCodeBlock (/Users/leesin/Desktop/blog/node_modules/hexo/lib/plugins/filter/before_post_render/backtick_code_block.js:14:31) at Hexo.tryCatcher (/Users/leesin/Desktop/blog/node_modules/bluebird/js/release/util.js:16:23) at Hexo.&lt;anonymous&gt; (/Users/leesin/Desktop/blog/node_modules/bluebird/js/release/method.js:15:34) at Promise.each.filter (/Users/leesin/Desktop/blog/node_modules/hexo/lib/extend/filter.js:63:65) at tryCatcher (/Users/leesin/Desktop/blog/node_modules/bluebird/js/release/util.js:16:23) at Object.gotValue (/Users/leesin/Desktop/blog/node_modules/bluebird/js/release/reduce.js:155:18) at Object.gotAccum (/Users/leesin/Desktop/blog/node_modules/bluebird/js/release/reduce.js:144:25) at Object.tryCatcher (/Users/leesin/Desktop/blog/node_modules/bluebird/js/release/util.js:16:23) at Promise._settlePromiseFromHandler (/Users/leesin/Desktop/blog/node_modules/bluebird/js/release/promise.js:512:31) at Promise._settlePromise (/Users/leesin/Desktop/blog/node_modules/bluebird/js/release/promise.js:569:18) at Promise._settlePromiseCtx (/Users/leesin/Desktop/blog/node_modules/bluebird/js/release/promise.js:606:10) at _drainQueueStep (/Users/leesin/Desktop/blog/node_modules/bluebird/js/release/async.js:142:12) at _drainQueue (/Users/leesin/Desktop/blog/node_modules/bluebird/js/release/async.js:131:9) 解决方法：将Hexo站点配置文件_config.yml中的 auto_detect设置为false ，如下所示：1auto_detect: false","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://linuxops.fun/categories/Hexo/"}],"tags":[]},{"title":"hexo-nexo主题配置中的问题","slug":"hexo-nexo主题配置中的问题","date":"2015-09-07T12:08:12.000Z","updated":"2019-12-16T01:41:04.657Z","comments":true,"path":"2015/09/07/2af6010.html","link":"","permalink":"https://linuxops.fun/2015/09/07/2af6010.html","excerpt":"","text":"​ 引子好久没写博客了，一时间发现作者更新了nexo主题版本，我就很自然的拉取最新版本，然后合并自己本地的博客主题源码，解决了好几个文件的冲突。看似是解决好了，不料在我 hexo clean ，hexo g 操作时，出现了问题：1234567891011121314151617181920212223242526272829303132333435363738$ hexo gERROR Script load failed: themes\\next\\scripts\\tags\\exturl.jsError: Cannot find module &apos;hexo-util&apos; at Function.Module._resolveFilename (module.js:325:15) at Function.Module._load (module.js:276:25) at Module.require (module.js:353:17) at require (D:\\myblog-hexo\\node_modules\\hexo\\lib\\hexo\\index.js:213:21) at D:\\myblog-hexo\\themes\\next\\scripts\\tags\\exturl.js:7:12 at D:\\myblog-hexo\\node_modules\\hexo\\lib\\hexo\\index.js:229:12 at tryCatcher (D:\\myblog-hexo\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Promise._settlePromiseFromHandler (D:\\myblog-hexo\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:502:31) at Promise._settlePromise (D:\\myblog-hexo\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:559:18) at Promise._settlePromise0 (D:\\myblog-hexo\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:604:10) at Promise._settlePromises (D:\\myblog-hexo\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:683:18) at Promise._fulfill (D:\\myblog-hexo\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:628:18) at Promise._resolveCallback (D:\\myblog-hexo\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:423:57) at Promise._settlePromiseFromHandler (D:\\myblog-hexo\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:514:17) at Promise._settlePromise (D:\\myblog-hexo\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:559:18) at Promise._settlePromise0 (D:\\myblog-hexo\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:604:10) at Promise._settlePromises (D:\\myblog-hexo\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:683:18) at Promise._fulfill (D:\\myblog-hexo\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\promise.js:628:18) at D:\\myblog-hexo\\node_modules\\hexo\\node_modules\\bluebird\\js\\release\\nodeback.js:42:21 at D:\\myblog-hexo\\node_modules\\hexo\\node_modules\\hexo-fs\\node_modules\\graceful-fs\\graceful-fs.js:78:16 at FSReqWrap.readFileAfterClose [as oncomplete] (fs.js:380:3)虽然这些错误不影响正常使用，不过有点强迫症的我，是不能接受的。查了一下百度，并没有发现和我相同问题的，结果厚着脸到作者源码仓库 iissnan/hexo-theme-next, 发布了一个 ISS，求解错误，得到热心的同学解答，现把自己解决方法记录下来！ 解决方案首先，错误列表反复提示 Error: Cannot find module 'hexo-util' 这句，原来是加载 hexo-util 模块失败！接下来，就安装此模块，在Hexo站点目录下执行以下命令 ：1# npm install hexo-util --save # 安装模块hexo-util返回内容显示如下：12345678910111213141516&gt; hexo-util@0.6.0 postinstall D:\\myblog-hexo\\node_modules\\hexo-util&gt; npm run build:highlight&gt; hexo-util@0.6.0 build:highlight D:\\myblog-hexo\\node_modules\\hexo-util&gt; node scripts/build_highlight_alias.js &gt; highlight_alias.jsonsave-dev@2.0.0 node_modules\\save-devhexo-util@0.6.0 node_modules\\hexo-util├── html-entities@1.2.0├── striptags@2.2.1├── bluebird@3.4.7├── highlight.js@9.9.0├── cross-spawn@4.0.2 (lru-cache@4.0.2, which@1.2.12)└── camel-case@3.0.0 (upper-case@1.1.3, no-case@2.3.1)显示为此，说明模块安装成功，再试 hexo clean 、hexo g 等操作，都正常了。总体来说，一般这些错误，都是模块的问题，知道了原理，再慢慢排查，就应该能解决相应的问题！","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://linuxops.fun/categories/Hexo/"}],"tags":[]},{"title":"Hexo博客Markdown文章插入图片方法总结","slug":"Hexo博客Markdown文章插入图片方法总结","date":"2015-09-06T10:16:12.000Z","updated":"2019-12-16T01:41:02.845Z","comments":true,"path":"2015/09/06/c7c81ce1.html","link":"","permalink":"https://linuxops.fun/2015/09/06/c7c81ce1.html","excerpt":"","text":"在网上查了一下有以下几种方式往Hexo博客Markdown文章中插入图片 本地引用 绝对路径当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。对于source/images/image.jpg这张图片可以用以下语法访问到1![](/images/image.jpg)图片既可以在首页内容中访问到，也可以在文章正文中访问到。 相对路径图片除了可以放在站点统一的source/images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置博客站点目录下的_config.yml来生成。1post_asset_folder: true将 _config.yml 文件中的配置项 post_asset_folder 设为 true 后，执行以下命令新建Markdown文章1# hexo new post_name # 新建Markdown文章，post_name即 是文章的标题，也是文件名.之后会在站点的 source/_posts 中会生成文章文件 post_name.md 和同名目录 post_name 。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。posts/post_name/image.jpg这张照片可以用以下方式访问：1![](image.jpg)上述markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。如果希望图片在文章和首页中可以同时显示，可以使用标签插件语法。_posts/post_name/image.jpg这张照片可以用以下方式访问：1&#123;% asset_img image.jpg This is an image %&#125;其中，image.jpg 是图片的文件名， This is an image 是一个描述信息，可不写。注意：用以上方式访问时，在Markdown的编辑器中无法预览效果。 CDN引用除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。因国内访问github速度较慢，所以将图片放到国内图床上，然后引用外链是常用的方法。常用图床总结：https://sspai.com/post/40499图床，也就是专门提供存储图片的地方，我们只要通过图床提供的 API 接口，把图片上传上去，就可以通过外链访问了，根本不用操心图片是怎么存的，硬盘空间不够了，硬盘坏了，访问速度比较慢等等问题，这些图床都会帮我们搞定，他们会用各种技术帮我们做图片相关的优化和服务，比如多机互备、CDN 加速、图片处理、图片鉴黄、文本识别等等。当然，图床也是有缺点的，当所有人都把图片存在同一个图床上，万一有一天图床真挂了，那所有图片就都无法访问了，虽然这种情况的概率很低，但并不等于不会发生目前图床可以分为两种，一种是公共图床，一种是自建图床。公共图床也就是利用公共服务的图片上传接口，来提供图片外链的服务，比如新浪微博。自建图床，也就是利用各大云服务商提供的存储空间或者自己在 VPS 上使用开源软件来搭建图床，存储图片，生成外链提供访问，比如七牛、Lychee 开源自建图床方案。微博图床（Chrome浏览器有个“新浪微博图床”插件，可以自动生成markdown链接）简单方便七牛：需要注册且实名认证等太麻烦，放弃腾讯云等云存储服务，需要先将照片放到云盘，然后找到超链接，然后粘贴到文章。太麻烦，放弃。【强烈推荐！！！】ipic 工具，具体用法请谷歌，支持监控剪贴板，一键上传到微博图床，免费版默认是微博图床，支持七牛云等 使用GitHub使用github存储博客图片创建一个空的repo然后将图片push到repo中点击图片进去，有个download，右键复制链接将链接插入文章，如下所示1![logo](https://github.com/xxxx/xx.jpg)","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://linuxops.fun/categories/Hexo/"}],"tags":[]},{"title":"Hexo常用命令总结","slug":"Hexo常用命令总结","date":"2015-09-05T11:30:12.000Z","updated":"2019-12-16T01:41:03.571Z","comments":true,"path":"2015/09/05/ee339324.html","link":"","permalink":"https://linuxops.fun/2015/09/05/ee339324.html","excerpt":"","text":"Hexo安装与升级12npm install -g hexo # 安装Hexo npm update -g hexo # 升级Hexo Hexo初始化站点与新建文章123hexo init # 初始化博客站点hexo new postName # 新建Markdown文章，postName为文章文件名称hexo new page &quot;pageName&quot; # 新建页面 Hexo服务启动1234hexo server # 前端开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo server -s # 静态模式hexo server -p 5000 # 指定端口启动hexo server -i 192.168.1.1 # 自定义 IP Hexo清除缓存1hexo clean # 清除缓存 网页正常情况下可以忽略此条命令 Hexo生成静态页1hexo generate # 生成静态页面至public目录 HEXO发布静态页到代码托管仓库1hexo deploy # 将.deploy目录部署到GitHub或其他代码托管仓库 Hexo命令简写12345hexo n postName == hexo new postName # 新建文章hexo p == hexo publish &lt;title&gt; # 移动草稿文章到source/_post目录hexo g == hexo generate # 生成静态页hexo s == hexo server # 前台启动服务预览hexo d == hexo deploy # 部署到到代码托管仓库 Hexo部署到代码托管仓库步骤如果deploy类型是git,则需要安装下面的模块$ npm install hexo-deployer-git --save123hexo clean # 清除Hexo静态页缓存hexo g # 生成静态网页hexo d # 开始部署 监视文件变动12hexo generate # 使用Hexo生成静态文件快速而且简单hexo generate --watch # 监视文件变动 生成静态页后部署两个命令的作用是相同的12hexo generate --deployhexo deploy --generate Hexo新建草稿文件1hexo publish [layout] &lt;title&gt; Hexo编写Markdown文档开头模板变量描述title标题date文件建立日期1234567title: Markdown文章模板 # 文章标题date: 2015-08-29 18:16:12 # 文章创建日期和时间categories: Tools # 文章分类tags: # 文章标签toc: true # 是否启用文章内容索引 option: truesidebar: # 是否启用sidebar侧边栏，默认开启侧边栏 option： none 不启用mathjax: # 是否启用数学公式渲染 option: true 设置文章摘要以上是文章摘要 &lt;!--more--&gt; 以下是余下全文","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://linuxops.fun/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://linuxops.fun/tags/Hexo/"}]},{"title":"Markdown工具介绍","slug":"Markdown工具介绍","date":"2015-09-04T12:30:16.000Z","updated":"2019-10-30T16:46:16.323Z","comments":true,"path":"2015/09/04/35e0eca1.html","link":"","permalink":"https://linuxops.fun/2015/09/04/35e0eca1.html","excerpt":"","text":"什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：如您正在阅读的这篇文章。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字.很多产品的文档也是用markdown编写的，并且以“README.md”的文件名保存在软件的目录下面。 基本语法标题H1 :# Header 1H2 :## Header 2H3 :### Header 3H4 :#### Header 4H5 :##### Header 5H6 :###### Header 6链接 :Title加粗 :Bold斜体字 :Italics删除线 :text 段落 : 段落之间空一行 换行符 : 一行结束时输入两个空格 列表 : 添加星号成为一个新的列表项。引用 :&gt; 引用内容内嵌代码 : alert('Hello World');画水平线 (HR) :——–css 的大部分语法同样可以在 markdown 上使用，但不同的渲染器渲染出来的 markdown 内容样式也不一样，下面这些链接里面有 markdown 基本语法，你也可以在下面几个平台上尝试着写一些。 常见的Markdown 编辑器Typora 是一款轻便简洁的Markdown编辑器,支持即时渲染技术。MaHua 在线 Markdown 编辑器 ,无须测试。Markdown Plus 一款 Markdown 编辑器，可以支持添加任务列表、emoji、流程图等。Cmd Markdown 作业部落在线 Markdown 编辑器推出桌面版客户端啦，全平台支援。Macdown Github 上开源的 Mac 平台上的 Markdown 编辑器GitBook Editor 一款团队在线编辑文档工具。可以轻松书写笔记，支持团队协同编辑。同时支持 Markdown 语法，还保持了印象笔记的风格并可在线预览。Outlinely 界面简洁大方的大纲类 Mac 软件，使用起来很简单，而且支持输出 Markdown 格式。DeerResume 程序员专用 MarkDown 简历制作在线工具。 Markdown语法参考网址Markdown菜鸟教程文档Markdown语法参考文档","categories":[{"name":"Tools","slug":"Tools","permalink":"https://linuxops.fun/categories/Tools/"}],"tags":[]},{"title":"第三方评论系统介绍","slug":"第三方评论系统整理","date":"2015-09-03T12:30:45.000Z","updated":"2019-12-16T01:41:04.661Z","comments":true,"path":"2015/09/03/1b34862d.html","link":"","permalink":"https://linuxops.fun/2015/09/03/1b34862d.html","excerpt":"","text":"网站经常要用到第三方社会化评论系统，评论可以增加用户之间的互动，到底有哪些社会化评论系统可供选择？常见的有：畅言、友言、来必力、Gitalk、Gitment等，有一些已经无法使用了。 畅言目前状态：可正常使用是否需要备案：是是否需要注册：是简介：大厂出品，稳定性、长久性都值得信赖。完美匹配PC端和移动端，拥有智能反垃圾系统。网址：http://changyan.kuaizhan.com/ 友言目前状态：可正常使用是否需要备案：否是否需要注册：否，如需获取个人专属评论系统需注册简介：支持单点登录，评论导入、导出、自适应PC端和移动端。系统审核不行，垃圾评论多。网址：http://www.uyan.cc/ 来必力目前状态：可正常使用是否需要备案：否是否需要注册：是简介：来比力(支持英语、中文、韩语)等少数几个，提供管理页面，管理网站评论内容。可手动隐藏恶性评论与灌水内容。主要应用在一些大型的新闻资讯站点上，支持社会化账号及Openid的登录，同样具有Voting功能。网址：https://livere.com/ Gitalk目前状态：可正常使用是否需要备案：否是否需要注册：是简介：Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。使用 GitHub 登录，支持多语言 [en, zh-CN, zh-TW, es-ES, fr, ru]，支持个人或组织，无干扰模式（设置 distractionFreeMode 为 true 开启），快捷键提交评论 （cmd|ctrl + enter）网址：https://github.com/gitalk/gitalk Gitment目前状态：可正常使用是否需要备案：否是否需要注册：是简介：Gitment是基于GitHub Issues的评论系统，无需任何服务器端实现即可在前端使用。GitHub登录，Markdown / GFM支持，语法高亮，来自GitHub的通知，易于定制，没有服务器端实现。网址：https://github.com/imsun/gitment Disqus目前状态：可正常使用，国外（可能需要翻墙）是否需要备案：否是否需要注册：是简介：可以使用在多个平台上，包括主流的Wordpress及Joomla, Dupral等等系统，很多大型网站都直接使用Disqus，也可以看出Disqus在第三评论系统里面的地位。它集成的第三方登录基本上是国外的，比如Facebook，Twitter，Google+，linkedin等。但是这种登录在国内基本都是用不了的。所以国内的博客系统或cms还是不推荐大家使用Disqus。网址：https://disqus.com/你还知道有哪些第三方评论系统？留言补充吧……","categories":[{"name":"Tools","slug":"Tools","permalink":"https://linuxops.fun/categories/Tools/"}],"tags":[]},{"title":"Hexo博客同时托管到Github和Coding","slug":"Hexo博客同时托管到github和coding","date":"2015-09-02T13:40:12.000Z","updated":"2019-12-16T01:41:03.568Z","comments":true,"path":"2015/09/02/a875106a.html","link":"","permalink":"https://linuxops.fun/2015/09/02/a875106a.html","excerpt":"","text":"​在 Coding 和 Github 上建立 pages 项目，按要求建立。不会的可以查看前面Hexo搭建个人博客系统这篇博客。 修改个Hexo站点配置_config.yml想要把博客同时部署到 coding 和 github 上，关键一步就是Hexo站点的_config.yml 配置。根据 Hexo 官方文档需要修改成下面的形式123456deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch]所以我的是这样：12345deploy: type: git repo: coding: git@e.coding.net:opsunion/blogsite.git,master github: git@github.com:Eddieeo/eddieeo.github.io.git,master我这边提交采用的 SSH 密钥，这个方法有个好处，提交的时候不用输入用户名和密码。如果你习惯用 http 的方式，只要将地址改成相应的 http 地址即可。 生成静态文件并发布前提：要想通过git将静态页发布到Coding和Github Pages上，必须确保Hexo站点目录下安装了hexo-deployer-git插件，可以在Hexo站点目录下执行以下命令安装该插件。1# npm install hexo-deployer-git --save然后使用generate指令生成静态文件，最后使用deploy部署命令就能把博客静态页同步到 coding 和 github 上12# hexo g # 生成静态文件# hexo d # 发布到coding和github上以上只是把 hexo 生成的静态文件部署到 coding 和 github 的 master 分支上。稍等片刻就能用系统给的地址访问到你的博客。注意发布到Coding需要开启 coding的持续部署静态网站功能 ，稍等片刻就能看到生成的博客访问地址了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://linuxops.fun/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://linuxops.fun/tags/Hexo/"}]},{"title":"Hexo搭建个人博客系统","slug":"Hexo搭建个人博客系统","date":"2015-09-01T12:40:12.000Z","updated":"2019-12-16T01:41:03.575Z","comments":true,"path":"2015/09/01/9af43afc.html","link":"","permalink":"https://linuxops.fun/2015/09/01/9af43afc.html","excerpt":"","text":"什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 系统环境Distributor ID: CentOSDescription: CentOS Linux release 7.6.1810 (Core)Release: 7.6.1810CPU: 2 Core内存容量: 2GGit Version: 1.8.3.1Nvm Version: 0.34.0Node.js Version: v12.10.0Npm Version: 6.11.3Hexo Version: 3.9.0Hexo-cli Version: 2.0.0 环境准备 安装GitLinux (CentOS):1# sudo yum -y install git-core 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。nvm 的开发者提供了一个自动安装 nvm 的简单脚本： 安装nvmCurl:1# curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | sh或Wget:1# wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | sh 使用nvm安装node安装完成后，重启终端并执行下列命令即可安装 Node.js。1# nvm install node 搭建Hexo博客系统 安装HexoNode 和 Git 都安装好后，可执行如下命令安装 Hexo：1npm install -g hexo-cli 初始化Blog目录然后，执行 init 命令初始化 Hexo 到你指定的目录：123# hexo init &lt;folder&gt;此处我们在用户家目录下的blog目录进行初始化# hexo init blog也可以 cd 到目标目录，执行 hexo init。 安装Hexo依赖包初始化完成后，cd进入该初始化的目录blog下，使用npm安装Hexo对应的依赖包。12# cd blog# npm install好啦，至此，全部安装工作已经完成！ 更换Hexo主题本文以 hexo-theme-pure 主题为例，安装主题的方法就是一句 git 命令：在终端命令行窗口下，切换到 Hexo 站点目录blog目录下。使用 Git checkout 代码：12# cd blog/theme# git clone https://github.com/Eddieeo/hexo-theme-pure.git themes/hexo-theme-pure安装完成后，打开Hexo站点目录blog的配置文件_config.yml，修改主题为 hexo-theme-pure1theme: hexo-theme-pure打开 blog/themes/hexo-theme-pure 目录，编辑主题配置文件_config.yml，修改自己想要的配置：12345678910111213141516171819202122232425# menumenu: Home: . Archives: archives # 归档 Categories: categories # 分类 Tags: tags # 标签 Repository: repository # github repositories Books: books # 豆瓣书单 Links: links # 友链 About: about # 关于# Enable/Disable menu iconsmenu_icons: enable: true # 是否启用导航菜单图标 home: icon-home-fill archives: icon-archives-fill categories: icon-folder tags: icon-tags repository: icon-project books: icon-book-fill links: icon-friendship about: icon-cup-fill# rssrss: /atom.xml主题其它使用配置及常见问题点此：主题hexo-theme-pure使用文档 更新主题切换到Hexo站点blog的主题hexo-theme-pure目录下12cd blog/themes/hexo-theme-puregit pull 写文章 使用系统默认编辑器vim编写Markdown文档执行 new 命令，生成指定名称的文章至 blog/source/_posts/postName.md。1hexo new [layout] &quot;postName&quot; # 新建文章其中 layout 是可选参数，默认值为 post。有哪些 layout 呢，请到 scaffolds 目录下查看，这些文件名称就是 layout 名称。当然你可以添加自己的 layout，方法就是添加一个文件即可，同时你也可以编辑现有的 layout，比如 post 的 layout 默认是 blog/scaffolds/post.md12345---title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:---请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示。我想添加 categories，以免每次手工输入，只需要修改这个文件添加一行，如下：123456---title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;categories: tags: ---postName 是 md 文件的名字，同时也出现在你文章的 URL 中，postName 如果包含空格，必须用 ’ ’ 将其包围，postName 可以为中文。注意：所有文件，开头要遵循YAML文件格式，即冒号: 后面都必须有个空格，不然会报错。看一下刚才生成的文件 hexo/source/_posts/postName.md，内容如下：1234567---title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: #文章分类目录，可以为空，注意:后面有个空格tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格---这里开始使用Markdown格式输入你的正文。 使用Windows上的图形编辑器Typora编写Markdown文档在Windows上安装软件Typora，开始编写Markdown文档，注意Markdown文档的开头必须有以下内容：1234567---title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: #文章分类目录，可以为空，注意:后面有个空格tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格---这里开始使用Markdown格式输入你的正文。将编写好的文档上传到Hexo服务器上的站点blog目录下的source/_post目录下，然后重启Hexo服务即可。关于Markdown 语法说明可以参考该链接：Markdown语法说明文档。Hexo 中所有文件的编码格式均是 UTF-8。 本地前台启动Hexo执行如下命令，启动本地服务，进行文章预览调试。1# hexo server # 简写命令 hexo s打开浏览器测试访问前，先禁用系统自带的防火墙firewalld和SELinux服务，执行如下命令1234# systemctl stop firewalld.service# systemctl disable firewalld.service# setenforce 0# sed -i &apos;s#SELINUX=enforcing#SELINUX=disabled#g&apos; /etc/selinux/config浏览器输入 http://IPADDRESS:4000 就可以看到效果，如下图所示：注：IPADDRESS，请使用ifconfig命令在服务器上查看 PM2工具管理Hexo开机自启且后台运行 安装PM2管理Hexo后台运行使用npm包管理器安装pm2工具1# npm install -g pm2在Hexo的初始化目录blog目录下，添加一个名叫 hexo_run.js 的脚本，脚本内容如下：1234567891011//this is a json script,be used for run hexo backstage//runconst &#123; exec &#125; = require(&apos;child_process&apos;)exec(&apos;hexo server&apos;,(error, stdout, stderr) =&gt; &#123; if(error)&#123; console.log(&apos;exec error: $&#123;error&#125;&apos;) return &#125; console.log(&apos;stdout: $&#123;stdout&#125;&apos;); console.log(&apos;stderr: $&#123;stderr&#125;&apos;);&#125;)使用以下命令可以使hexo在后台运行123# pm2 start hexo_run.js # 启动Hexo# pm2 stop hexo_run.js # 停止Hexo# pm2 restart hexo_run.js # 重启Hexo PM2设置开机自启动1234# pm2 save # 保存当前pm2进程状态# pm2 startup # 生成开机自启动命令# systemctl start pm2-root.service # 启动pm2-root.service服务# systemctl enable pm2-root.service # 设置pm2-root.service开机自启 部署静态页面到Github Pages 或 Coding Pages 注册申请GitHub用户或Coding用户GitHub用户和Coding用的注册，此处不做介绍，自行百度解决。 配置SSH连接Github或Coding 添加 SSH-Key首先设置你的用户名和邮箱地址：12# git config --global user.name &quot;username&quot;# git config --global user.email &quot;email@example.com&quot; 生成密钥1# ssh-keygen -t rsa -C &quot;email@example.com&quot;想简单，过程一路回车。12345678# ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 你的email帐户Generating public/private rsa key pair.Enter file in which to save the key (/c/Documents and Settings/Administrator/.ssh/id_rsa): （设置保存公钥和私钥的位置，保持默认，可以不填直接回车）Enter passphrase (empty for no passphrase): （读取id_rsa的密码，可不填，不过建议填写）Enter same passphrase again: （再次输入id_rsa密码确认）Your identification has been saved in /c/Documents and Settings/Administrator/.ssh/id_rsa.Your public key has been saved in /c/Documents and Settings/Administrator/.ssh/id_rsa.pub.The key fingerprint is:生成的KEY 你的email帐户上述命令若执行成功，会在 /root/.ssh/ 目录下生成两个文件 id_rsa 和 id_rsa.pub。 添加ssh密钥到Github在命令行用cat命令读取 id_rsa.pub 文件，拷贝其中的内容，登录Github，找到settings—&gt;SSH and GPG keys—&gt;New SSH key，将公钥粘贴到弹出的Key对话框中，并输入Title；然后单击Add SSH key ，完成SSH密钥添加，如下图所示。 最后，在Hexo服务器命令行界面可以验证一下：1# ssh -T git@github.com顺利的话可以看到下面的信息，第一次使用SSH连接Github，会提示你确认连接，输入yes即可。The authenticity of host ‘github.com (52.74.223.119)’ can’t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.RSA key fingerprint is MD5:16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added ‘github.com,52.74.223.119’ (RSA) to the list of known hosts.Hi Eddieeo! You’ve successfully authenticated, but GitHub does not provide shell access. 添加ssh密钥到Coding在命令行用cat命令读取 id_rsa.pub 文件，拷贝其中的内容，登录Coding，找到个人设置—&gt;SSH公钥—&gt;新增公钥，将公钥粘贴到弹出的公钥内容对话框中，并输入公钥名称，修改公钥有效期；然后单击添加 ，完成SSH密钥添加，如下图所示。 最后，在Hexo服务器命令行界面可以验证一下：1# ssh -T git@e.coding.net顺利的话可以看到下面的信息，第一次使用SSH连接Coding，会提示你确认连接，输入yes即可。The authenticity of host ‘e.coding.net (118.126.70.252)’ can’t be established.RSA key fingerprint is SHA256:jok3FH7q5LJ6qvE7iPNehBgXRw51ErE77S0Dn+Vg/Ik.RSA key fingerprint is MD5:98🆎2b:30:60:00:82:86:bb:85:db:87:22:c4:4f:b1.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added ‘e.coding.net,118.126.70.252’ (RSA) to the list of known hosts.Coding 提示: Hello eddieeo, You’ve connected to Coding.net via SSH. This is a personal key.eddieeo，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个个人公钥 部署到Github Pages 创建代码仓库使用上面注册的用户登录Github官网，然后点击首页的 Start a project 按钮，创建一个公开的代码仓库，如下图所示，其中Repository name 一定要填写成 username.github.io，username就是你Github的登录用户名。 修改Hexo站点配置文件_config.yml修改博客站点的配置文件_config.yml，将deploy的配置修改为如下:1234deploy: type: git repository: git@github.com:Eddieeo/eddieeo.github.io.git branch: master 生成静态页面cd 到你的Hexo站点的初始化目录blog下，清除上次生成静态页面留下的缓存，执行如下命令：1# hexo clean # 清除缓存 网页正常情况下可以忽略此条命令然后执行如下命令，生成静态页面至当前路径下的 public 目录。1# hexo generate # 生成静态页，简写命令 hexo g命令必须在 站点目录下执行，否则不成功，但是也不报错。当你修改文章 Tag 或其他内容时，不能正确重新生成内容，可以删除 hexo\\db.json 后重试，还不行就到 public 目录删除对应的文件，重新生成。 发布到Github Pages前提：要想通过git部署，必须确保Hexo站点目录下有安装 hexo-deployer-git 插件，可以在Hexo站点目录下执行以下命令安装该插件1# npm install hexo-deployer-git --save然后cd 到你的Hexo站点的初始化目录blog下，执行如下命令进行发布1# hexo deploy # 简写命令 hexo d看到类似如下图所示的返回，即表示发布成功。 部署到Coding Pages 创建代码仓库使用上面注册的用户登录Coding官网，然后点击首页的全部项目按钮，创建一个私有的项目，如下图所示，其中项目名称任意填写。 修改Hexo站点配置文件_config.yml修改博客站点的配置文件_config.yml，将deploy的配置修改为如下:1234deploy: type: git repository: git@e.coding.net:itunion/blog.git branch: master 生成静态页面cd 到你的Hexo站点的初始化目录blog下，清除上次生成静态页面留下的缓存，执行如下命令：1# hexo clean # 清除缓存 网页正常情况下可以忽略此条命令然后执行如下命令，生成静态页面至当前路径下的 public 目录。1# hexo generate # 生成静态页，简写命令 hexo g命令必须在 站点目录下执行，否则不成功，但是也不报错。当你修改文章 Tag 或其他内容时，不能正确重新生成内容，可以删除 hexo\\db.json 后重试，还不行就到 public 目录删除对应的文件，重新生成。 发布到Coding Pages前提：要想通过git部署，必须确保Hexo站点目录下有安装 hexo-deployer-git 插件，可以在Hexo站点目录下执行以下命令安装该插件1# npm install hexo-deployer-git --save然后cd 到你的Hexo站点的初始化目录blog下，执行如下命令进行发布1# hexo deploy # 简写命令 hexo d看到类似如下图所示的返回，即表示发布成功。 开启静态网站登录Coding网站，进入到blog项目，设置开启静态网站。 同时部署到Github Pages和Coding Pages 创建代码仓库分别在Github Pages和Coding Pages新建好仓库和项目，此步骤可以参考前面的内容。 修改Hexo站点配置文件_config.yml修改博客站点的配置文件_config.yml，将deploy的配置修改为如下:12345deploy: type: git repo: github: git@e.coding.net:itunion/blog.git,master coding: git@github.com:Eric-Cai/Eric-Cai.github.io.git,master 生成静态页面cd 到你的Hexo站点的初始化目录blog下，清除上次生成静态页面留下的缓存，执行如下命令：1# hexo clean # 清除缓存 网页正常情况下可以忽略此条命令然后执行如下命令，生成静态页面至当前路径下的 public 目录。1# hexo generate # 生成静态页，简写命令 hexo g命令必须在 站点目录下执行，否则不成功，但是也不报错。当你修改文章 Tag 或其他内容时，不能正确重新生成内容，可以删除 hexo\\db.json 后重试，还不行就到 public 目录删除对应的文件，重新生成。 同时发布到Github Pages和Coding Pages前提：要想通过git部署，必须确保Hexo站点目录下有安装 hexo-deployer-git 插件，可以在Hexo站点目录下执行以下命令安装该插件1# npm install hexo-deployer-git --save然后cd 到你的Hexo站点的初始化目录blog下，执行如下命令进行发布1# hexo deploy # 简写命令 hexo d看到类似如下图所示的返回，即表示发布成功。 Hexo 命令 常用命令：123456hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo clean # 清除缓存 网页正常情况下可以忽略此条命令hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHub 常用复合命令：12hexo deploy -ghexo server -g 简写：1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy至此，基本操作介绍完毕，以下内容普通用户无需了解。 目录介绍 默认目录结构：1234567891011.├── .deploy├── public├── scaffolds├── scripts├── source| ├── _drafts| └── _posts├── themes├── _config.yml└── package.json.deploy：执行 hexo deploy 命令部署到 GitHub 上的内容目录public：执行 hexo generate 命令，输出的静态网页内容目录scaffolds：layout 模板文件目录，其中的 md 文件可以添加编辑scripts：扩展脚本目录，这里可以自定义一些 javascript 脚本source：文章源码目录，该目录下的 markdown 和 html 文件均会被 hexo 处理。该页面对应 repo 的根目录，404 文件、favicon.ico 文件，CNAME 文件等都应该放这里，该目录下可新建页面目录。_drafts：草稿文章_posts：发布文章themes：主题文件目录_config.yml：全局配置文件，大多数的设置都在这里package.json：应用程序数据，指明 hexo 的版本等信息，类似于一般软件中的关于按钮接下来是重头戏_config.yml，做个简单说明：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# Hexo Configuration## Docs: http://zespia.tw/hexo/docs/configure.html## Source: https://github.com/tommy351/hexo/# Site #整站的基本信息title: 不如 #网站标题subtitle: 码农，程序猿，未来的昏析师 #网站副标题description: bruce sha&apos;s blog | java | scala | bi #网站描述，给搜索引擎用的，在生成html中的head-&gt;meta中可看到author: bruce #网站作者，在下方显示email: bu.ru@qq.com #联系邮箱language: zh-CN #语言# URL #域名和文件结构## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://ibruce.info #你的域名root: /permalink: :year/:month/:day/:title/tag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/code# Writing #写文章选项new_post_name: :title.md # File name of new postsdefault_layout: post #默认layout方式auto_spacing: false # Add spaces between asian characters and western characterstitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabmax_open_file: 100multi_thread: truefilename_case: 0render_drafts: falsehighlight: #代码高亮 enable: true #是否启用 line_number: false #是否显示行号 tab_replace:# Category &amp; Tag #分类与标签default_category: uncategorized # defaultcategory_map:tag_map:# Archives #存档，这里的说明好像不对。全部选择1，这个选项与主题中的选项有时候会有冲突## 2: Enable pagination## 1: Disable pagination## 0: Fully Disablearchive: 1category: 1tag: 1# Server #本地服务参数## Hexo uses Connect as a server## You can customize the logger format as defined in## http://www.senchalabs.org/connect/logger.htmlport: 4000logger: truelogger_format:# Date / Time format #日期显示格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: MMM D YYYYtime_format: H:mm:ss# Pagination #分页设置## Set per_page to 0 to disable paginationper_page: 10 #每页10篇文章pagination_dir: page# Disqus #社会化评论disqus，我使用多说，在主题中配置disqus_shortname:# Extensions #插件，暂时未安装插件## Plugins: https://github.com/tommy351/hexo/wiki/Plugins## Themes: https://github.com/tommy351/hexo/wiki/Themes## 主题theme: modernist # raytaylorism # pacman # modernist # lightexclude_generator:# Deployment #部署## Docs: http://zespia.tw/hexo/docs/deploy.htmldeploy: type: git #repository: git@e.coding.net:opsunion/blogsite.git repository: git@github.com:Eddieeo/eddieeo.github.io.git #你的GitHub Pages仓库 branch: master 修改局部页面页面展现的全部逻辑都在每个主题中控制，源代码在 站点目录/themes/你使用的主题/ 中，以 hexo-theme-pure 主题为例：123456789101112131415161718.├── languages #多语言| ├── default.yml #默认语言| └── zh-CN.yml #中文语言├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _partial #局部的布局，此目录下的*.ejs是对头尾等局部的控制| └── _widget #小挂件的布局，页面下方小挂件的控制├── source #源码| ├── css #css源码 | | ├── _base #*.styl基础css| | ├── _partial #*.styl局部css| | ├── fonts #字体| | ├── images #图片| | └── style.styl #*.styl引入需要的css源码| ├── fancybox #fancybox效果源码| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 更新 更新 hexo：1# npm update -g hexo 更新主题：12# cd 站点目录/themes/你的主题# git pull 更新插件：12# cd 站点目录/# npm update","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://linuxops.fun/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://linuxops.fun/tags/Hexo/"}]},{"title":"Windows微信多开教程","slug":"Windows微信多开教程","date":"2015-08-31T13:40:12.000Z","updated":"2019-12-16T01:41:04.658Z","comments":true,"path":"2015/08/31/c4e0fb25.html","link":"","permalink":"https://linuxops.fun/2015/08/31/c4e0fb25.html","excerpt":"","text":"前提Windows上实现打开多个微信的前提条件是，当前后台没有微信程序在运行。 方法一：通过键盘加鼠标同时打开两个微信先按住键盘的 Enter 键，然后移动鼠标左键点击一下桌面的微信图标，再松开 Enter 键。你会在桌面看到弹出微信程序的登录方框，用鼠标拖动微信程序的登录方框，即可以看到多个微信了，这样就实现微信多开了。 方法二：使用Windows批处理实现右键单击桌面的微信快捷图标，选择打开文件所在的位置，找到微信程序的安装路径并复制，在桌面新建一个txt文件，命名为多微信启动，粘贴以下内容：123TASKKILL /F /IM wechat.exestart &quot;&quot; &quot;C:\\Program Files (x86)\\Tencent\\WeChat\\WeChat.exe&quot;start &quot;&quot; &quot;C:\\Program Files (x86)\\Tencent\\WeChat\\WeChat.exe&quot;最后，修改txt文件的后缀名为bat格式，保存退出，双击该bat文件，你会在桌面看到弹出微信程序的登录方框，用鼠标拖动微信程序的登录方框，即可以看到多个微信了，这样就实现微信多开了。想要打开多少个微信程序，只要将这行代码复制多行就行1start &quot;&quot; &quot;C:\\Program Files (x86)\\Tencent\\WeChat\\WeChat.exe&quot;注意：代码中微信程序的绝对路径需要用双引号引起来，而且前两个双引号和第三个双引号中间有一个空格","categories":[{"name":"Windows","slug":"Windows","permalink":"https://linuxops.fun/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://linuxops.fun/tags/Windows/"}]},{"title":"Windows10基本操作习惯","slug":"Windows10基本操作习惯","date":"2015-08-29T13:10:10.000Z","updated":"2019-12-16T01:41:03.577Z","comments":true,"path":"2015/08/29/11a80162.html","link":"","permalink":"https://linuxops.fun/2015/08/29/11a80162.html","excerpt":"","text":"本文主要介绍Windows10系统的一些基本操作习惯。Windows10 系统的输入法切换默认是Win键 + 空格键，我们已经习惯了Windows7系统以前的Ctrl + Shift的切换模式，下面教大家如何在Windows10下进行修改成Windows7下默认的Ctrl + Shift切换模式。打开 设置—&gt; 时间和语言 —&gt; 语言—&gt; 拼写、键入和键盘设置—&gt; 输入 —&gt; 高级键盘设置 —&gt; 语言栏选项","categories":[{"name":"Windows","slug":"Windows","permalink":"https://linuxops.fun/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://linuxops.fun/tags/Windows/"}]},{"title":"Windows专业版永久密钥","slug":"Windows专业版永久密钥","date":"2015-08-29T11:13:12.000Z","updated":"2019-12-16T01:41:03.574Z","comments":true,"path":"2015/08/29/6a0826e7.html","link":"","permalink":"https://linuxops.fun/2015/08/29/6a0826e7.html","excerpt":"","text":"​ 很多人都在找 Win10 专业版永久密钥，其实 Win10 激活码不管版本新旧都是通用的，也就是说一个 Win10 专业版 key，可以同时激活 Windows10 专业版 1809、1803、1709、1703、1607、1511 等全部新旧版本。​ 下面给大家分享 Win10 专业版永久密钥（支持重装），以及激活方法。数字权利激活是永久性的激活，在同一台电脑上主要硬件（应该是 CPU 和主板）不变化的情况下，重新安装系统时无需再次输入密钥，安装后会系统自动激活。Win10 专业版永久密钥（支持重装）: Win10 专业版产品密钥NXRQM-CXV6P-PBGVJ-293T4-R3KTYDR9VN-GF3CR-RCWT2-H7TR8-82QGT步骤：开始–设置–更新和安全–激活–更改产品密钥。 Win10 1083 专业版 KMS 客户端安装密钥Windows 10 Professional (专业版)：W269N-WFGWX-YVC9B-4J6C9-T83GXWindows 10 Professional N (专业版 N)：MH37W-N47XK-V7XM9-C7227-GCQG9 Win10 KMS 客户端安装密钥 永久有效 Operating system edition (操作系统版本)：KMS Client Setup Key (KMS 客户端安装序列号)Windows 10 Professional (专业版)：W269N-WFGWX-YVC9B-4J6C9-T83GXWindows 10 Professional N (专业版 N)：MH37W-N47XK-V7XM9-C7227-GCQG9Windows 10 Enterprise (企业版)：NPPR9-FWDCX-D2C8J-H872K-2YT43Windows 10 Enterprise N (企业版 N)：DPH2V-TTNVB-4X9Q3-TJR4H-KHJW4Windows 10 Education (教育版)：NW6C2-QMPVW-D7KKK-3GKT6-VCFB2Windows 10 Education N (教育版 N)：2WH4N-8QGBV-H22JP-CT43Q-MDWWJ Windows10 企业版长期服务分支：Windows 10 Enterprise 2015 LTSB：WNMTR-4C88C-JK8YV-HQ7T2-76DF9Windows 10 Enterprise 2015 LTSB N：2F77B-TNFGY-69QQF-B8YKP-D69TJWindows 10 Enterprise 2016 LTSB：DCPHK-NFMTC-H88MJ-PFHPY-QJ4BJWindows 10 Enterprise 2016 LTSB N：QFFDN-GRT3P-VKWWX-X7T3R-8B639 Windows10 Home（Win10 家庭版激活码）TX9XD-98N7V-6WMQ6-BX7FG-H8Q993KHY7-WNT83-DGQKR-F7HPR-844BM7HNRX-D7KGG-3K4RQ-4WPJ4-YTDFHPVMJN-6DFY6-9CCP6-7BKTT-D3WVRPPBK3-M92CH-MRR9X-34Y9P-7CH2F (OA 3.0 版)Win10 家庭版 37GNV-YCQVD-38XP9-T848R-FC2HDWin10 家庭版 N 33C4Y-NPKCC-V98JP-42G8W-VH636 (非 OA 3.0 版)Win10 家庭版 46J3N-RY6B3-BJFDY-VBFT9-V22HGWin10 家庭版 N PGGM7-N77TC-KVR98-D82KJ-DGPHV Win10 企业政府版 400 年期限密钥 (相当于永久激活密匙)【EnterpriseG】FV469-WGNG4-YQP66-2B2HY-KD8YX【EnterpriseGN】FW7NV-4T673-HF4VX-9X4MM-B4H4T【gvlkEnterpriseG】YYVX9-NTFWV-6MDM3-9PT4T-4M68B【gvlkEnterpriseGN】44RPN-FTY23-9VTTB-MP9BX-T84FV","categories":[{"name":"Windows","slug":"Windows","permalink":"https://linuxops.fun/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://linuxops.fun/tags/Windows/"}]},{"title":"Markdown文章模板","slug":"Markdown文章模板","date":"2015-08-29T10:16:12.000Z","updated":"2019-10-30T16:46:16.334Z","comments":true,"path":"2015/08/29/817bfc99.html","link":"","permalink":"https://linuxops.fun/2015/08/29/817bfc99.html","excerpt":"","text":"这是一个Markdown的文章模板，写Markdown文档时必须在文档的开头添加以下信息。特别注意：此段开头必须是用 YAML Front Matter 的格式输入，注意YAML的语法格式。title: # 文章标题date: # 文章创建日期和时间categories: # 文章分类tags: # 文章标签toc: # 是否启用文章内容索引 option: truesidebar: # 是否启用sidebar侧边栏，默认开启侧边栏 option： none 不启用mathjax: # 是否启用数学公式渲染 option: true","categories":[{"name":"Tools","slug":"Tools","permalink":"https://linuxops.fun/categories/Tools/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2015-08-29T08:21:30.000Z","updated":"2019-10-30T16:46:16.335Z","comments":true,"path":"2015/08/29/16107.html","link":"","permalink":"https://linuxops.fun/2015/08/29/16107.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\"More info: Writing Run server1$ hexo serverMore info: Server Generate static files1$ hexo generateMore info: Generating Deploy to remote sites1$ hexo deployMore info: Deployment","categories":[],"tags":[]}]}